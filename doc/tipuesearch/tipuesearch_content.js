var tipuesearch = {"pages":[{"title":" SPECTRUM ","text":"SPECTRUM Developer Info Jason Christopherson","tags":"home","loc":"index.html"},{"title":"blackman_harris_window – SPECTRUM ","text":"type, public, extends( window ) :: blackman_harris_window Defines a Blackman-Harris window. See Also Wikipedia Contents Variables size Type-Bound Procedures evaluate Components Type Visibility Attributes Name Initial integer(kind=int32), public :: size = 0 The window size. Type-Bound Procedures procedure, public :: evaluate => bhw_eval private pure function bhw_eval(this, bin) result(rst) Evaluates the window function. Arguments Type Intent Optional Attributes Name class( blackman_harris_window ), intent(in) :: this The blackman_harris_window object. integer(kind=int32), intent(in) :: bin The index or bin number [0, n], where n is the window size. Return Value real(kind=real64) The function value.","tags":"","loc":"type\\blackman_harris_window.html"},{"title":"flat_top_window – SPECTRUM ","text":"type, public, extends( window ) :: flat_top_window Defines a flat-top window. See Also Wikipedia Contents Variables size Type-Bound Procedures evaluate Components Type Visibility Attributes Name Initial integer(kind=int32), public :: size = 0 The window size. Type-Bound Procedures procedure, public :: evaluate => ftw_eval private pure function ftw_eval(this, bin) result(rst) Evaluates the window function. Arguments Type Intent Optional Attributes Name class( flat_top_window ), intent(in) :: this The flat_top_window object. integer(kind=int32), intent(in) :: bin The index or bin number [0, n], where n is the window size. Return Value real(kind=real64) The function value.","tags":"","loc":"type\\flat_top_window.html"},{"title":"hamming_window – SPECTRUM ","text":"type, public, extends( window ) :: hamming_window Defines a Hamming window. See Also Wikipedia Contents Variables size Type-Bound Procedures evaluate Components Type Visibility Attributes Name Initial integer(kind=int32), public :: size = 0 The window size. Type-Bound Procedures procedure, public :: evaluate => hamming_eval private pure function hamming_eval(this, bin) result(rst) Evaluates the window function. Arguments Type Intent Optional Attributes Name class( hamming_window ), intent(in) :: this The hamming_window object. integer(kind=int32), intent(in) :: bin The index or bin number [0, n], where n is the window size. Return Value real(kind=real64) The function value.","tags":"","loc":"type\\hamming_window.html"},{"title":"hann_window – SPECTRUM ","text":"type, public, extends( window ) :: hann_window Defines a Hann window. . See Also Wikipedia Contents Variables size Type-Bound Procedures evaluate Components Type Visibility Attributes Name Initial integer(kind=int32), public :: size = 0 The window size. Type-Bound Procedures procedure, public :: evaluate => hann_eval private pure function hann_eval(this, bin) result(rst) Evaluates the window function. Arguments Type Intent Optional Attributes Name class( hann_window ), intent(in) :: this The hann_window object. integer(kind=int32), intent(in) :: bin The index or bin number [0, n], where n is the window size. Return Value real(kind=real64) The function value.","tags":"","loc":"type\\hann_window.html"},{"title":"rectangular_window – SPECTRUM ","text":"type, public, extends( window ) :: rectangular_window @brief Defines a rectangular window.\nDefines a rectangular window. Contents Variables size Type-Bound Procedures evaluate Components Type Visibility Attributes Name Initial integer(kind=int32), public :: size = 0 The window size. Type-Bound Procedures procedure, public :: evaluate => rw_eval private pure function rw_eval(this, bin) result(rst) Evaluates the window function. Arguments Type Intent Optional Attributes Name class( rectangular_window ), intent(in) :: this The rectangular_window object. integer(kind=int32), intent(in) :: bin The index or bin number [0, n], where n is the window size. Return Value real(kind=real64) The function value.","tags":"","loc":"type\\rectangular_window.html"},{"title":"welch_window – SPECTRUM ","text":"type, public, extends( window ) :: welch_window Defines a Welch window. See Also Wikipedia Contents Variables size Type-Bound Procedures evaluate Components Type Visibility Attributes Name Initial integer(kind=int32), public :: size = 0 The window size. Type-Bound Procedures procedure, public :: evaluate => welch_eval private pure function welch_eval(this, bin) result(rst) Evaluates the window function. Arguments Type Intent Optional Attributes Name class( welch_window ), intent(in) :: this The welch_window object. integer(kind=int32), intent(in) :: bin The index or bin number [0, n], where n is the window size. Return Value real(kind=real64) The function value.","tags":"","loc":"type\\welch_window.html"},{"title":"window – SPECTRUM ","text":"type, public, abstract :: window Defines the structure of a window. Contents Variables size Type-Bound Procedures evaluate Components Type Visibility Attributes Name Initial integer(kind=int32), public :: size = 0 The window size. Type-Bound Procedures procedure( window_function ), public, deferred, pass :: evaluate pure function window_function(this, bin) result(rst) Prototype Evaluates the window function. Arguments Type Intent Optional Attributes Name class( window ), intent(in) :: this The window object. integer(kind=int32), intent(in) :: bin The index or bin number [0, n], where n is the window size. Return Value real(kind=real64) The function value.","tags":"","loc":"type\\window.html"},{"title":"convolve – SPECTRUM","text":"public  function convolve(x, y, method, err) result(rst) Computes the convolution of a signal and kernel. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x (:) The N-element signal. real(kind=real64), intent(in) :: y (:) The M-element kernel. integer(kind=int32), intent(in), optional :: method An optional input that dictates the expected\nconvolution result.  The following options are available. SPCTRM_FULL_CONVOLUTION: The full convolution results are provided, \n    including the portions polluted courtesy of the zero-padding and\n    the corresponding wrap-around effects.  The length of this output\n    is N + M - 1. SPCTRM_CENTRAL_CONVOLUTION: The N-element result containing the \n    convolved signal not poluted by the zero-padding and \n    corresponding wrap-around effects. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided can\nbe used to retrieve information relating to any errors encountered \nduring execution.  If not provided, a default implementation of the \nerrors class is used internally to provide error handling.  Possible \nerrors and warning messages that may be encountered are as follows. SPCTRM_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory \n     available. Return Value real(kind=real64), allocatable, (:) The convolved result. Contents","tags":"","loc":"proc\\convolve.html"},{"title":"stencil_diff_5 – SPECTRUM","text":"public  function stencil_diff_5(dt, x, err) result(rst) Utilizes a 5-point stencil to estimate the derivative of a data set. See Also Wikipedia Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: dt The time step between data points. real(kind=real64), intent(in), dimension(:) :: x An N-element array containing the data whose derivative is to be \nestimated. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided can\nbe used to retrieve information relating to any errors encountered \nduring execution.  If not provided, a default implementation of the \nerrors class is used internally to provide error handling.  Possible \nerrors and warning messages that may be encountered are as follows. SPCTRM_MEMORY_ERROR: Occurs if a memory allocation error occurs. Return Value real(kind=real64), allocatable, dimension(:) An N-element array containing the derivative estimate. Contents","tags":"","loc":"proc\\stencil_diff_5.html"},{"title":"tvr_derivative – SPECTRUM","text":"public  function tvr_derivative(dt, x, alpha, maxiter, tol, niter, err) result(rst) Computes an estimate to the derivative of an evenly-sampled data\nset using total variation regularization. See Also van Breugel, Floris & Brunton, Bingni & Kutz, J.. (2020). Numerical \n  differentiation of noisy data: A unifying multi-objective optimization \n  framework. Oliver K. Ernst, Ph. D. (2021, February 16). How to differentiate \n  noisy signals. Medium. https://oliver-k-ernst.medium.com/how-to-differentiate-noisy-signals-2baf71b8bb65 Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: dt The time step between data points. real(kind=real64), intent(in), dimension(:) :: x An N-element array containing the data whose derivative is\nto be estimated. real(kind=real64), intent(in) :: alpha The regularization parameter. integer(kind=int32), intent(in), optional :: maxiter The maximum number of iterations to allow.  The default is 20 \niterations. real(kind=real64), intent(in), optional :: tol The convergence tolerance to use.  The tolerance is \napplied to the difference in Euclidean norms of the derivative update\nvector.  Once the norm of the update vector is changing less than \nthis tolerance, the iteration process will terminate.  The default\nis 1e-3. integer(kind=int32), intent(out), optional :: niter The number of iterations actually performed. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided can\nbe used to retrieve information relating to any errors encountered \nduring execution.  If not provided, a default implementation of the \nerrors class is used internally to provide error handling.  Possible \nerrors and warning messages that may be encountered are as follows. SPCTRM_MEMORY_ERROR: Occurs if a memory allocation error occurs. SPCTRM_SINGULAR_MATRIX_ERROR: Occurs if the internal Hessian \n     estimate becomes singular. Return Value real(kind=real64), allocatable, dimension(:) An N-element array containing the estimate of the derivative. Contents","tags":"","loc":"proc\\tvr_derivative.html"},{"title":"finite_difference – SPECTRUM","text":"public interface finite_difference Contents Module Procedures finite_difference_1 finite_difference_2 Module Procedures private  function finite_difference_1(dt, x, err) result(rst) Estimates the derivative of a data set by means of a naive \nimplementation of a finite difference scheme based upon central \ndifferences. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: dt The time step between data points. real(kind=real64), intent(in), dimension(:) :: x An N-element array containing the data whose derivative is to be \nestimated. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided can\nbe used to retrieve information relating to any errors encountered \nduring execution.  If not provided, a default implementation of the \nerrors class is used internally to provide error handling.  Possible \nerrors and warning messages that may be encountered are as follows. SPCTRM_MEMORY_ERROR: Occurs if a memory allocation error occurs. Return Value real(kind=real64), allocatable, dimension(:) An N-element array containing the derivative estimate. private  function finite_difference_2(t, x, err) result(rst) Computes an estimate to the derivative of an evenly-sampled data\nset using total variation regularization. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: t An N-element array containing the time points at which x was sampled. real(kind=real64), intent(in), dimension(:) :: x An N-element array containing the data whose derivative is to be \nestimated. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided can\nbe used to retrieve information relating to any errors encountered \nduring execution.  If not provided, a default implementation of the \nerrors class is used internally to provide error handling.  Possible \nerrors and warning messages that may be encountered are as follows. SPCTRM_MEMORY_ERROR: Occurs if a memory allocation error occurs. SPCTRM_ARRAY_SIZE_MISMATCH_ERROR: Occurs if t and x are not the\n     same size. Return Value real(kind=real64), allocatable, dimension(:) An N-element array containing the derivative estimate.","tags":"","loc":"interface\\finite_difference.html"},{"title":"stft – SPECTRUM","text":"public  function stft(win, x, offsets, err) result(rst) Computes the short time Fourier transform of a signal. See Also Wikipedia - Short Time Fourier Transform Arguments Type Intent Optional Attributes Name class( window ), intent(in) :: win The window to apply. real(kind=real64), intent(in) :: x (:) The signal to analyze.  The signal must be longer than the size of \nthe window. integer(kind=int32), intent(out), optional, allocatable :: offsets (:) An optional allocatable array that, if supplied, will be filled with \nthe starting indices of each window segment. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided can\nbe used to retrieve information relating to any errors encountered \nduring execution.  If not provided, a default implementation of the \nerrors class is used internally to provide error handling.  Possible \nerrors and warning messages that may be encountered are as follows. SPCTRM_MEMORY_ERROR: Occurs if a memory allocation error occurs. SPCTRM_INVALID_INPUT_ERROR: Occurs if the signal in x is too short\n     relative to the window size in win. Return Value complex(kind=real64), allocatable, (:,:) An M-by-N matrix containing the M-element complex-valued \ntransforms for each of the N time points studied.  M is the size of \nthe positive half of the transform, and N is the total number of \ntransformed segments. Contents","tags":"","loc":"proc\\stft.html"},{"title":"filter – SPECTRUM","text":"public  function filter(b, a, x, delays, err) result(rst) Applies the specified filter to a signal. The description of the filter in the Z-transform domain is a rational\ntransfer function of the form: ,\nwhich handles both IIR and FIR filters. The above form assumes a\nnormalization of a(1) = 1; however, the routine will appropriately \nhandle the situation where a(1) is not set to one. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: b (:) The numerator coefficients of the rational transfer function. real(kind=real64), intent(in) :: a (:) The denominator coefficients of the ration transfer function.  In \nthe case of an FIR filter, this parameter should be set to a \none-element array with a value of one.  Regardless, the value of\na(1) must be non-zero. real(kind=real64), intent(in) :: x (:) An N-element array containing the signal to filter. real(kind=real64), intent(inout), optional, target :: delays (:) An optional array of length \nMAX(size(a), size(b)) - 1 that, on input, provides the initial \nconditions for filter delays, and on ouput, the final conditions for \nfilter delays. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided can\nbe used to retrieve information relating to any errors encountered \nduring execution.  If not provided, a default implementation of the \nerrors class is used internally to provide error handling.  Possible \nerrors and warning messages that may be encountered are as follows. SPCTRM_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory \n     available. SPCTRM_INVALID_INPUT_ERROR: Occurs if a(1) is zero. SPCTRM_ARRAY_SIZE_ERROR: Occurs if a is not sized correctly, or if\n     delays is not sized correctly. Return Value real(kind=real64), allocatable, (:) An N-element array containing the filtered signal. Contents","tags":"","loc":"proc\\filter.html"},{"title":"gaussian_filter – SPECTRUM","text":"public  function gaussian_filter(x, alpha, k, err) result(rst) Applies a Gaussian filter to a signal. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x (:) An N-element array containing the signal to filter. real(kind=real64), intent(in) :: alpha A parameter that specifies the number of standard deviations desired in the kernel.  This parameter is related to the \nstandard deviation by . integer(kind=int32), intent(in) :: k The kernel size.  This value must be a positive, non-zero\ninteger value less than N. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided can\nbe used to retrieve information relating to any errors encountered \nduring execution.  If not provided, a default implementation of the \nerrors class is used internally to provide error handling.  Possible \nerrors and warning messages that may be encountered are as follows. SPCTRM_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory \n     available. SPCTRM_INVALID_INPUT_ERROR: Occurs if k is not within the proper\n     bounds. Return Value real(kind=real64), allocatable, (:) An N-element array containing the filtered signal. Contents","tags":"","loc":"proc\\gaussian_filter.html"},{"title":"moving_average_filter – SPECTRUM","text":"public  function moving_average_filter(navg, x, err) result(rst) Applies a moving average filter to a signal. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: navg The size of the averaging window.  This parameter must be positive\nand non-zero. real(kind=real64), intent(in) :: x (:) An N-element array containing the signal to filter. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided can\nbe used to retrieve information relating to any errors encountered \nduring execution.  If not provided, a default implementation of the \nerrors class is used internally to provide error handling.  Possible \nerrors and warning messages that may be encountered are as follows. SPCTRM_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory \n     available. SPCTRM_INVALID_INPUT_ERROR: Occurs if navg is less than one. Return Value real(kind=real64), allocatable, (:) An N-element array containing the filtered signal. Contents","tags":"","loc":"proc\\moving_average_filter.html"},{"title":"tv_filter – SPECTRUM","text":"public  function tv_filter(x, lambda, niter, err) result(rst) Applies a total-variation filter to a signal. The algorithm used by this routine is based upon the algorithm presented \nby [Selesnick and Bayram]\n(https://eeweb.engineering.nyu.edu/iselesni/lecture_notes/TV_filtering.pdf). Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x (:) An N-element array containing the signal to filter. real(kind=real64), intent(in) :: lambda The regularization parameter.  The actual value to use\nis problem dependent, but the noisier the data, the larger this value\nshould be.  A good starting point is typically 0.3 - 0.5; however, the\nactual value is problem dependent. integer(kind=int32), intent(in), optional :: niter An optional parameter controlling the number of iterations performed.\nThe default limit is 10 iterations. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided can\nbe used to retrieve information relating to any errors encountered \nduring execution.  If not provided, a default implementation of the \nerrors class is used internally to provide error handling.  Possible \nerrors and warning messages that may be encountered are as follows. SPCTRM_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory \n     available. SPCTRM_INVALID_INPUT_ERROR: Occurs if niter is less than one. Return Value real(kind=real64), allocatable, (:) An N-element array containing the filtered signal. Contents","tags":"","loc":"proc\\tv_filter.html"},{"title":"cross_periodogram – SPECTRUM","text":"public module function cross_periodogram(win, x, y, fs, nfft, err) result(rst) Computes the cross-spectral periodogram of two signals. Arguments Type Intent Optional Attributes Name class( window ), intent(in) :: win The window to apply.  The size of the window must be non-zero and \npositive-valued. real(kind=real64), intent(in) :: x (:) The first N-element signal to transform. real(kind=real64), intent(in) :: y (:) The second N-element signal to transform. real(kind=real64), intent(in), optional :: fs An optional input, that if supplied, allows for normalization of \nthe computed spectrum by the frequency resolution. integer(kind=int32), intent(in), optional :: nfft An optional input that can be used to force the length of each\nindividual DFT operation by padding any remaining space with zeros.\nIf not supplied, the window size is used to determine the size of\nthe DFT. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided can\nbe used to retrieve information relating to any errors encountered \nduring execution.  If not provided, a default implementation of the \nerrors class is used internally to provide error handling.  Possible \nerrors and warning messages that may be encountered are as follows. SPCTRM_MEMORY_ERROR: Occurs if a memory allocation error occurs. SPCTRM_INVALID_INPUT_ERROR: Occurs if win is not sized \n     appropriately. SPCTRM_ARRAY_SIZE_MISMATCH_ERROR: Occurs if x and y are not the\n     same size, or if x and y are not the same size as the window\n     win. Return Value complex(kind=real64), allocatable, (:) An array containing the discrete cross periodogram estimate.  The \nestimate is returned at discrete frequency intervals that can be \ndetermined by a call to frequency_bin_width. Contents","tags":"","loc":"proc\\cross_periodogram.html"},{"title":"csd – SPECTRUM","text":"public  function csd(win, x, y, fs, nfft, err) result(rst) Computes the cross spectral density (CSD) of a signal via Welch's\nmethod (sometimes referred to as cross power spectral density\nor CPSD). References Welch, P.D. \"The Use of Fast Fourier Transform for the Estimation of \n Power Spectra: A Method Based on Time Averaging Over Short, Modified \n Periodograms.\" IEEE Transactions on Audio and Electroacoustics, \n AU-15 (2): 70-73, 1967. Wikipedia - Welch's Method Wikipedia - Cross Power Spectral Density Arguments Type Intent Optional Attributes Name class( window ), intent(in) :: win The window to apply.  The size of the window must be non-zero and \npositive-valued. real(kind=real64), intent(in) :: x (:) The first N-element signal to transform. real(kind=real64), intent(in) :: y (:) The second N-element signal to transform. real(kind=real64), intent(in), optional :: fs An optional input, that if supplied, allows for normalization of \nthe computed spectrum by the frequency resolution. integer(kind=int32), intent(in), optional :: nfft An optional input that can be used to force the length of each\nindividual DFT operation by padding any remaining space with zeros.\nIf not supplied, the window size is used to determine the size of\nthe DFT. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided can\nbe used to retrieve information relating to any errors encountered \nduring execution.  If not provided, a default implementation of the \nerrors class is used internally to provide error handling.  Possible \nerrors and warning messages that may be encountered are as follows. SPCTRM_MEMORY_ERROR: Occurs if a memory allocation error occurs. SPCTRM_INVALID_INPUT_ERROR: Occurs if win is not sized \n     appropriately. SPCTRM_ARRAY_SIZE_MISMATCH_ERROR: Occurs if x and y are not the \n     same size. Return Value complex(kind=real64), allocatable, (:) An array containing the discrete CSD estimate.  The estimate is\nreturned at discrete frequency intervals that can be determined by\na call to frequency_bin_width. Contents","tags":"","loc":"proc\\csd.html"},{"title":"periodogram – SPECTRUM","text":"public module function periodogram(win, x, fs, nfft, err) result(rst) Computes the periodogram of a signal. Arguments Type Intent Optional Attributes Name class( window ), intent(in) :: win The window to apply.  The size of the window must be non-zero and \npositive-valued. real(kind=real64), intent(in) :: x (:) The signal to transform. real(kind=real64), intent(in), optional :: fs An optional input, that if supplied, allows for normalization of \nthe computed spectrum by the frequency resolution. integer(kind=int32), intent(in), optional :: nfft An optional input that can be used to force the length of each\nindividual DFT operation by padding any remaining space with zeros.\nIf not supplied, the window size is used to determine the size of\nthe DFT. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided can\nbe used to retrieve information relating to any errors encountered \nduring execution.  If not provided, a default implementation of the \nerrors class is used internally to provide error handling.  Possible \nerrors and warning messages that may be encountered are as follows. SPCTRM_MEMORY_ERROR: Occurs if a memory allocation error occurs. SPCTRM_INVALID_INPUT_ERROR: Occurs if win is not sized \n     appropriately. Return Value real(kind=real64), allocatable, (:) An array containing the discrete PSD estimate.  The estimate is\nreturned at discrete frequency intervals that can be determined by\na call to frequency_bin_width. Contents","tags":"","loc":"proc\\periodogram.html"},{"title":"psd – SPECTRUM","text":"public  function psd(win, x, fs, nfft, err) result(rst) Computes the power spectral density (PSD) of a signal via Welch's\nmethod. References Welch, P.D. \"The Use of Fast Fourier Transform for the Estimation of \n Power Spectra: A Method Based on Time Averaging Over Short, Modified \n Periodograms.\" IEEE Transactions on Audio and Electroacoustics, \n AU-15 (2): 70-73, 1967. Wikipedia - Welch's Method Arguments Type Intent Optional Attributes Name class( window ), intent(in) :: win The window to apply.  The size of the window must be non-zero and \npositive-valued. real(kind=real64), intent(in) :: x (:) The signal to transform. real(kind=real64), intent(in), optional :: fs An optional input, that if supplied, allows for normalization of \nthe computed spectrum by the frequency resolution. integer(kind=int32), intent(in), optional :: nfft An optional input that can be used to force the length of each\nindividual DFT operation by padding any remaining space with zeros.\nIf not supplied, the window size is used to determine the size of\nthe DFT. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided can\nbe used to retrieve information relating to any errors encountered \nduring execution.  If not provided, a default implementation of the \nerrors class is used internally to provide error handling.  Possible \nerrors and warning messages that may be encountered are as follows. SPCTRM_MEMORY_ERROR: Occurs if a memory allocation error occurs. SPCTRM_INVALID_INPUT_ERROR: Occurs if win is not sized \n     appropriately. Return Value real(kind=real64), allocatable, (:) An array containing the discrete PSD estimate.  The estimate is\nreturned at discrete frequency intervals that can be determined by\na call to frequency_bin_width. Contents","tags":"","loc":"proc\\psd.html"},{"title":"compute_overlap_segment_count – SPECTRUM","text":"public pure function compute_overlap_segment_count(n, winsize) result(rst) Computes the number of overlapped signals using a nominal 50% overlap. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n The total length of the signal being overlapped. integer(kind=int32), intent(in) :: winsize The window size. Return Value integer(kind=int32) The number of segments. Contents","tags":"","loc":"proc\\compute_overlap_segment_count.html"},{"title":"compute_transform_length – SPECTRUM","text":"public pure function compute_transform_length(n) result(rst) Computes the length of the positive half of a discrete Fourier\ntransform for a specific signal length. The length of the discrete Fourier transform is determined as follows. If n is even, else; . Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n The signal length (length of the signal put forth to the Fourier \ntransform). Return Value integer(kind=int32) The length of the positive half of the discrete Fourier transform. Contents","tags":"","loc":"proc\\compute_transform_length.html"},{"title":"cumulative_sum – SPECTRUM","text":"public pure function cumulative_sum(x) result(rst) Computes the cumulative sum of an array. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x (:) The N-element array on which to operate. Return Value real(kind=real64), allocatable, (:) An N-element array containing the cumulative sum of each element\nin x (e.g. cumulative_sum(x) = [x(1), x(1) + x(2), ...]). Contents","tags":"","loc":"proc\\cumulative_sum.html"},{"title":"difference – SPECTRUM","text":"public pure function difference(x) result(rst) Computes the difference between each element in an array. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x (:) The N-element array on which to operate. Return Value real(kind=real64), allocatable, (:) The N-1 element array containing the difference between each element\nin x. Contents","tags":"","loc":"proc\\difference.html"},{"title":"frequency_bin_width – SPECTRUM","text":"public pure elemental function frequency_bin_width(fs, n) result(rst) Computes the bin width for a discrete frequency spectrum based\nupon the data sample rate. The frequency bin width is computed as follows. where m is computed via compute_transform_length. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: fs The rate at which the signal was sampled.  The units of this value \nwill be the units of the output. integer(kind=int32), intent(in) :: n The signal length (length of the signal put forth to the\nFourier transform). Return Value real(kind=real64) The frequency bin width. Contents","tags":"","loc":"proc\\frequency_bin_width.html"},{"title":"is_power_of_two – SPECTRUM","text":"public pure elemental function is_power_of_two(n) result(rst) Tests to see if a value is an integer power of two. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n The value to test. Return Value logical Returns true if n is a power of two; else, false. Contents","tags":"","loc":"proc\\is_power_of_two.html"},{"title":"next_power_of_two – SPECTRUM","text":"public pure elemental function next_power_of_two(n) result(rst) Provides the next higher integer power of two. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n The value to test. Return Value integer(kind=int32) The next power of two higher than n.  If n is already a power of two,\nits value is simply returned.  For instance, if n is set to 128, \nthen a value of 7 is returned ( ). Contents","tags":"","loc":"proc\\next_power_of_two.html"},{"title":"overlap – SPECTRUM","text":"public pure subroutine overlap(x, seg, winsize, buffer) Extracts a segment from a signal allowing for a nominally 50% overlap. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x (:) An N-element array containing the entire signal. integer(kind=int32), intent(in) :: seg The one-based index of the segment to extract. integer(kind=int32), intent(in) :: winsize The size of the window (segment).  If this value is less than N, the \nend of the segment will be padded with zeros. real(kind=real64), intent(out) :: buffer (:) A winsize array where the segment will be written. Contents","tags":"","loc":"proc\\overlap.html"},{"title":"unpack_real_transform – SPECTRUM","text":"public pure subroutine unpack_real_transform(x, cx, fac) Unpacks a real-valued transform into its complex-valued format. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x (:) The complex-valued signal stored in a real-valued array.  This array\nis assumed to be of length N. complex(kind=real64), intent(out) :: cx (:) The M-element array where the complex form of x is written.  M is\ndetermined by calling compute_transform_length(N). real(kind=real64), intent(in), optional :: fac An optional scaling input.  The default is 1 such that no scaling\nis performed. Contents","tags":"","loc":"proc\\unpack_real_transform.html"},{"title":"unwrap – SPECTRUM","text":"public  subroutine unwrap(x, tol) Shifts phase angle arrays to deal with jumps greater than or equal\nto tol by adding multiples of until\nthe jump is less than tol. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: x (:) On input, the phase array.  On output, the unwrapped phase array. real(kind=real64), intent(in), optional :: tol The tolerance value. Contents","tags":"","loc":"proc\\unwrap.html"},{"title":"siso_transfer_function – SPECTRUM","text":"public  function siso_transfer_function(win, x, y, etype, nfft, err) result(rst) Estimates the transfer function for a single-input/single-output\n(SISO) system. Arguments Type Intent Optional Attributes Name class( window ), intent(in) :: win The window object. real(kind=real64), intent(in) :: x (:) An N-element array containing the input signal. real(kind=real64), intent(in) :: y (:) An N-element array containing the output signal. integer(kind=int32), intent(in), optional :: etype An optional input that, if supplied, denotes the\nestimator to use.  If no value is specified, an H1 estimator is used.\nThe following options are supported. SPCTRM_H1_ESTIMATOR: Uses an H1 estimate. SPCTRM_H2_ESTIMATOR: Uses an H2 estimate. If an unrecognized value is provided, the routine defaults to an \nH1 estimator. integer(kind=int32), intent(in), optional :: nfft An optional input that can be used to force the length of each\nindividual DFT operation by padding any remaining space with zeros.\nIf not supplied, the window size is used to determine the size of\nthe DFT. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided can\nbe used to retrieve information relating to any errors encountered \nduring execution.  If not provided, a default implementation of the \nerrors class is used internally to provide error handling.  Possible \nerrors and warning messages that may be encountered are as follows. SPCTRM_MEMORY_ERROR: Occurs if a memory allocation error occurs. SPCTRM_INVALID_INPUT_ERROR: Occurs if win is not sized \n     appropriately. Return Value complex(kind=real64), allocatable, (:) Returns the complex-valued transfer function estimate. Contents","tags":"","loc":"proc\\siso_transfer_function.html"},{"title":"window_function – SPECTRUM","text":"interface public pure function window_function(this, bin) result(rst) Arguments Type Intent Optional Attributes Name class( window ), intent(in) :: this The window object. integer(kind=int32), intent(in) :: bin The index or bin number [0, n], where n is the window size. Return Value real(kind=real64) The function value. Description Evaluates the window function.","tags":"","loc":"interface\\window_function.html"},{"title":"spectrum – SPECTRUM","text":"Uses spectrum_tf spectrum_convolve spectrum_periodogram spectrum_fft spectrum_routines spectrum_filter spectrum_windows spectrum_diff Contents None","tags":"","loc":"module\\spectrum.html"},{"title":"spectrum_convolve – SPECTRUM","text":"Uses iso_fortran_env fftpack ferror spectrum_errors Contents Variables SPCTRM_CENTRAL_CONVOLUTION SPCTRM_FULL_CONVOLUTION Functions convolve Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: SPCTRM_CENTRAL_CONVOLUTION = 50001 A flag for requesting the central portion of the convolution that is \nthe same length as the input signal. integer(kind=int32), public, parameter :: SPCTRM_FULL_CONVOLUTION = 50000 A flag for requesting a full convolution. Functions public  function convolve (x, y, method, err) result(rst) Computes the convolution of a signal and kernel. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x (:) The N-element signal. real(kind=real64), intent(in) :: y (:) The M-element kernel. integer(kind=int32), intent(in), optional :: method An optional input that dictates the expected\nconvolution result.  The following options are available. Read more… class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided can\nbe used to retrieve information relating to any errors encountered \nduring execution.  If not provided, a default implementation of the \nerrors class is used internally to provide error handling.  Possible \nerrors and warning messages that may be encountered are as follows. Read more… Return Value real(kind=real64), allocatable, (:) The convolved result.","tags":"","loc":"module\\spectrum_convolve.html"},{"title":"spectrum_diff – SPECTRUM","text":"Uses iso_fortran_env blas ferror spectrum_errors linalg Contents Interfaces finite_difference Functions stencil_diff_5 tvr_derivative Interfaces public        interface finite_difference private  function finite_difference_1(dt, x, err) result(rst) Estimates the derivative of a data set by means of a naive \nimplementation of a finite difference scheme based upon central \ndifferences. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: dt The time step between data points. real(kind=real64), intent(in), dimension(:) :: x An N-element array containing the data whose derivative is to be \nestimated. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided can\nbe used to retrieve information relating to any errors encountered \nduring execution.  If not provided, a default implementation of the \nerrors class is used internally to provide error handling.  Possible \nerrors and warning messages that may be encountered are as follows. SPCTRM_MEMORY_ERROR: Occurs if a memory allocation error occurs. Return Value real(kind=real64), allocatable, dimension(:) An N-element array containing the derivative estimate. private  function finite_difference_2(t, x, err) result(rst) Computes an estimate to the derivative of an evenly-sampled data\nset using total variation regularization. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: t An N-element array containing the time points at which x was sampled. real(kind=real64), intent(in), dimension(:) :: x An N-element array containing the data whose derivative is to be \nestimated. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided can\nbe used to retrieve information relating to any errors encountered \nduring execution.  If not provided, a default implementation of the \nerrors class is used internally to provide error handling.  Possible \nerrors and warning messages that may be encountered are as follows. SPCTRM_MEMORY_ERROR: Occurs if a memory allocation error occurs. SPCTRM_ARRAY_SIZE_MISMATCH_ERROR: Occurs if t and x are not the\n     same size. Return Value real(kind=real64), allocatable, dimension(:) An N-element array containing the derivative estimate. Functions public  function stencil_diff_5 (dt, x, err) result(rst) Utilizes a 5-point stencil to estimate the derivative of a data set. Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: dt The time step between data points. real(kind=real64), intent(in), dimension(:) :: x An N-element array containing the data whose derivative is to be \nestimated. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided can\nbe used to retrieve information relating to any errors encountered \nduring execution.  If not provided, a default implementation of the \nerrors class is used internally to provide error handling.  Possible \nerrors and warning messages that may be encountered are as follows. Read more… Return Value real(kind=real64), allocatable, dimension(:) An N-element array containing the derivative estimate. public  function tvr_derivative (dt, x, alpha, maxiter, tol, niter, err) result(rst) Computes an estimate to the derivative of an evenly-sampled data\nset using total variation regularization. Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: dt The time step between data points. real(kind=real64), intent(in), dimension(:) :: x An N-element array containing the data whose derivative is\nto be estimated. real(kind=real64), intent(in) :: alpha The regularization parameter. integer(kind=int32), intent(in), optional :: maxiter The maximum number of iterations to allow.  The default is 20 \niterations. real(kind=real64), intent(in), optional :: tol The convergence tolerance to use.  The tolerance is \napplied to the difference in Euclidean norms of the derivative update\nvector.  Once the norm of the update vector is changing less than \nthis tolerance, the iteration process will terminate.  The default\nis 1e-3. integer(kind=int32), intent(out), optional :: niter The number of iterations actually performed. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided can\nbe used to retrieve information relating to any errors encountered \nduring execution.  If not provided, a default implementation of the \nerrors class is used internally to provide error handling.  Possible \nerrors and warning messages that may be encountered are as follows. Read more… Return Value real(kind=real64), allocatable, dimension(:) An N-element array containing the estimate of the derivative.","tags":"","loc":"module\\spectrum_diff.html"},{"title":"spectrum_errors – SPECTRUM","text":"Uses iso_fortran_env Contents Variables SPCTRM_ARRAY_SIZE_ERROR SPCTRM_ARRAY_SIZE_MISMATCH_ERROR SPCTRM_INVALID_INPUT_ERROR SPCTRM_MEMORY_ERROR SPCTRM_SINGULAR_MATRIX_ERROR Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: SPCTRM_ARRAY_SIZE_ERROR = 10003 integer(kind=int32), public, parameter :: SPCTRM_ARRAY_SIZE_MISMATCH_ERROR = 10002 integer(kind=int32), public, parameter :: SPCTRM_INVALID_INPUT_ERROR = 10001 integer(kind=int32), public, parameter :: SPCTRM_MEMORY_ERROR = 10000 integer(kind=int32), public, parameter :: SPCTRM_SINGULAR_MATRIX_ERROR = 10004","tags":"","loc":"module\\spectrum_errors.html"},{"title":"spectrum_fft – SPECTRUM","text":"Uses iso_fortran_env fftpack ferror spectrum_errors spectrum_routines spectrum_windows Contents Functions stft Functions public  function stft (win, x, offsets, err) result(rst) Computes the short time Fourier transform of a signal. Read more… Arguments Type Intent Optional Attributes Name class( window ), intent(in) :: win The window to apply. real(kind=real64), intent(in) :: x (:) The signal to analyze.  The signal must be longer than the size of \nthe window. integer(kind=int32), intent(out), optional, allocatable :: offsets (:) An optional allocatable array that, if supplied, will be filled with \nthe starting indices of each window segment. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided can\nbe used to retrieve information relating to any errors encountered \nduring execution.  If not provided, a default implementation of the \nerrors class is used internally to provide error handling.  Possible \nerrors and warning messages that may be encountered are as follows. Read more… Return Value complex(kind=real64), allocatable, (:,:) An M-by-N matrix containing the M-element complex-valued \ntransforms for each of the N time points studied.  M is the size of \nthe positive half of the transform, and N is the total number of \ntransformed segments.","tags":"","loc":"module\\spectrum_fft.html"},{"title":"spectrum_filter – SPECTRUM","text":"Uses iso_fortran_env spectrum_convolve ferror spectrum_errors spectrum_routines Contents Functions filter gaussian_filter moving_average_filter tv_filter Functions public  function filter (b, a, x, delays, err) result(rst) Applies the specified filter to a signal. Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: b (:) The numerator coefficients of the rational transfer function. real(kind=real64), intent(in) :: a (:) The denominator coefficients of the ration transfer function.  In \nthe case of an FIR filter, this parameter should be set to a \none-element array with a value of one.  Regardless, the value of\na(1) must be non-zero. real(kind=real64), intent(in) :: x (:) An N-element array containing the signal to filter. real(kind=real64), intent(inout), optional, target :: delays (:) An optional array of length \nMAX(size(a), size(b)) - 1 that, on input, provides the initial \nconditions for filter delays, and on ouput, the final conditions for \nfilter delays. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided can\nbe used to retrieve information relating to any errors encountered \nduring execution.  If not provided, a default implementation of the \nerrors class is used internally to provide error handling.  Possible \nerrors and warning messages that may be encountered are as follows. Read more… Return Value real(kind=real64), allocatable, (:) An N-element array containing the filtered signal. public  function gaussian_filter (x, alpha, k, err) result(rst) Applies a Gaussian filter to a signal. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x (:) An N-element array containing the signal to filter. real(kind=real64), intent(in) :: alpha A parameter that specifies the number of standard deviations desired in the kernel.  This parameter is related to the \nstandard deviation by . integer(kind=int32), intent(in) :: k The kernel size.  This value must be a positive, non-zero\ninteger value less than N. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided can\nbe used to retrieve information relating to any errors encountered \nduring execution.  If not provided, a default implementation of the \nerrors class is used internally to provide error handling.  Possible \nerrors and warning messages that may be encountered are as follows. Read more… Return Value real(kind=real64), allocatable, (:) An N-element array containing the filtered signal. public  function moving_average_filter (navg, x, err) result(rst) Applies a moving average filter to a signal. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: navg The size of the averaging window.  This parameter must be positive\nand non-zero. real(kind=real64), intent(in) :: x (:) An N-element array containing the signal to filter. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided can\nbe used to retrieve information relating to any errors encountered \nduring execution.  If not provided, a default implementation of the \nerrors class is used internally to provide error handling.  Possible \nerrors and warning messages that may be encountered are as follows. Read more… Return Value real(kind=real64), allocatable, (:) An N-element array containing the filtered signal. public  function tv_filter (x, lambda, niter, err) result(rst) Applies a total-variation filter to a signal. Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x (:) An N-element array containing the signal to filter. real(kind=real64), intent(in) :: lambda The regularization parameter.  The actual value to use\nis problem dependent, but the noisier the data, the larger this value\nshould be.  A good starting point is typically 0.3 - 0.5; however, the\nactual value is problem dependent. integer(kind=int32), intent(in), optional :: niter An optional parameter controlling the number of iterations performed.\nThe default limit is 10 iterations. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided can\nbe used to retrieve information relating to any errors encountered \nduring execution.  If not provided, a default implementation of the \nerrors class is used internally to provide error handling.  Possible \nerrors and warning messages that may be encountered are as follows. Read more… Return Value real(kind=real64), allocatable, (:) An N-element array containing the filtered signal.","tags":"","loc":"module\\spectrum_filter.html"},{"title":"spectrum_periodogram – SPECTRUM","text":"Uses iso_fortran_env fftpack ferror spectrum_errors spectrum_routines spectrum_windows Contents Functions cross_periodogram csd periodogram psd Functions public module function cross_periodogram (win, x, y, fs, nfft, err) result(rst) Computes the cross-spectral periodogram of two signals. Arguments Type Intent Optional Attributes Name class( window ), intent(in) :: win The window to apply.  The size of the window must be non-zero and \npositive-valued. real(kind=real64), intent(in) :: x (:) The first N-element signal to transform. real(kind=real64), intent(in) :: y (:) The second N-element signal to transform. real(kind=real64), intent(in), optional :: fs An optional input, that if supplied, allows for normalization of \nthe computed spectrum by the frequency resolution. integer(kind=int32), intent(in), optional :: nfft An optional input that can be used to force the length of each\nindividual DFT operation by padding any remaining space with zeros.\nIf not supplied, the window size is used to determine the size of\nthe DFT. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided can\nbe used to retrieve information relating to any errors encountered \nduring execution.  If not provided, a default implementation of the \nerrors class is used internally to provide error handling.  Possible \nerrors and warning messages that may be encountered are as follows. Read more… Return Value complex(kind=real64), allocatable, (:) An array containing the discrete cross periodogram estimate.  The \nestimate is returned at discrete frequency intervals that can be \ndetermined by a call to frequency_bin_width. public  function csd (win, x, y, fs, nfft, err) result(rst) Computes the cross spectral density (CSD) of a signal via Welch's\nmethod (sometimes referred to as cross power spectral density\nor CPSD). Read more… Arguments Type Intent Optional Attributes Name class( window ), intent(in) :: win The window to apply.  The size of the window must be non-zero and \npositive-valued. real(kind=real64), intent(in) :: x (:) The first N-element signal to transform. real(kind=real64), intent(in) :: y (:) The second N-element signal to transform. real(kind=real64), intent(in), optional :: fs An optional input, that if supplied, allows for normalization of \nthe computed spectrum by the frequency resolution. integer(kind=int32), intent(in), optional :: nfft An optional input that can be used to force the length of each\nindividual DFT operation by padding any remaining space with zeros.\nIf not supplied, the window size is used to determine the size of\nthe DFT. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided can\nbe used to retrieve information relating to any errors encountered \nduring execution.  If not provided, a default implementation of the \nerrors class is used internally to provide error handling.  Possible \nerrors and warning messages that may be encountered are as follows. Read more… Return Value complex(kind=real64), allocatable, (:) An array containing the discrete CSD estimate.  The estimate is\nreturned at discrete frequency intervals that can be determined by\na call to frequency_bin_width. public module function periodogram (win, x, fs, nfft, err) result(rst) Computes the periodogram of a signal. Arguments Type Intent Optional Attributes Name class( window ), intent(in) :: win The window to apply.  The size of the window must be non-zero and \npositive-valued. real(kind=real64), intent(in) :: x (:) The signal to transform. real(kind=real64), intent(in), optional :: fs An optional input, that if supplied, allows for normalization of \nthe computed spectrum by the frequency resolution. integer(kind=int32), intent(in), optional :: nfft An optional input that can be used to force the length of each\nindividual DFT operation by padding any remaining space with zeros.\nIf not supplied, the window size is used to determine the size of\nthe DFT. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided can\nbe used to retrieve information relating to any errors encountered \nduring execution.  If not provided, a default implementation of the \nerrors class is used internally to provide error handling.  Possible \nerrors and warning messages that may be encountered are as follows. Read more… Return Value real(kind=real64), allocatable, (:) An array containing the discrete PSD estimate.  The estimate is\nreturned at discrete frequency intervals that can be determined by\na call to frequency_bin_width. public  function psd (win, x, fs, nfft, err) result(rst) Computes the power spectral density (PSD) of a signal via Welch's\nmethod. Read more… Arguments Type Intent Optional Attributes Name class( window ), intent(in) :: win The window to apply.  The size of the window must be non-zero and \npositive-valued. real(kind=real64), intent(in) :: x (:) The signal to transform. real(kind=real64), intent(in), optional :: fs An optional input, that if supplied, allows for normalization of \nthe computed spectrum by the frequency resolution. integer(kind=int32), intent(in), optional :: nfft An optional input that can be used to force the length of each\nindividual DFT operation by padding any remaining space with zeros.\nIf not supplied, the window size is used to determine the size of\nthe DFT. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided can\nbe used to retrieve information relating to any errors encountered \nduring execution.  If not provided, a default implementation of the \nerrors class is used internally to provide error handling.  Possible \nerrors and warning messages that may be encountered are as follows. Read more… Return Value real(kind=real64), allocatable, (:) An array containing the discrete PSD estimate.  The estimate is\nreturned at discrete frequency intervals that can be determined by\na call to frequency_bin_width.","tags":"","loc":"module\\spectrum_periodogram.html"},{"title":"spectrum_routines – SPECTRUM","text":"Uses iso_fortran_env Contents Functions compute_overlap_segment_count compute_transform_length cumulative_sum difference frequency_bin_width is_power_of_two next_power_of_two Subroutines overlap unpack_real_transform unwrap Functions public pure function compute_overlap_segment_count (n, winsize) result(rst) Computes the number of overlapped signals using a nominal 50% overlap. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n The total length of the signal being overlapped. integer(kind=int32), intent(in) :: winsize The window size. Return Value integer(kind=int32) The number of segments. public pure function compute_transform_length (n) result(rst) Computes the length of the positive half of a discrete Fourier\ntransform for a specific signal length. Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n The signal length (length of the signal put forth to the Fourier \ntransform). Return Value integer(kind=int32) The length of the positive half of the discrete Fourier transform. public pure function cumulative_sum (x) result(rst) Computes the cumulative sum of an array. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x (:) The N-element array on which to operate. Return Value real(kind=real64), allocatable, (:) An N-element array containing the cumulative sum of each element\nin x (e.g. cumulative_sum(x) = [x(1), x(1) + x(2), ...]). public pure function difference (x) result(rst) Computes the difference between each element in an array. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x (:) The N-element array on which to operate. Return Value real(kind=real64), allocatable, (:) The N-1 element array containing the difference between each element\nin x. public pure elemental function frequency_bin_width (fs, n) result(rst) Computes the bin width for a discrete frequency spectrum based\nupon the data sample rate. Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: fs The rate at which the signal was sampled.  The units of this value \nwill be the units of the output. integer(kind=int32), intent(in) :: n The signal length (length of the signal put forth to the\nFourier transform). Return Value real(kind=real64) The frequency bin width. public pure elemental function is_power_of_two (n) result(rst) Tests to see if a value is an integer power of two. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n The value to test. Return Value logical Returns true if n is a power of two; else, false. public pure elemental function next_power_of_two (n) result(rst) Provides the next higher integer power of two. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n The value to test. Return Value integer(kind=int32) The next power of two higher than n.  If n is already a power of two,\nits value is simply returned.  For instance, if n is set to 128, \nthen a value of 7 is returned ( ). Subroutines public pure subroutine overlap (x, seg, winsize, buffer) Extracts a segment from a signal allowing for a nominally 50% overlap. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x (:) An N-element array containing the entire signal. integer(kind=int32), intent(in) :: seg The one-based index of the segment to extract. integer(kind=int32), intent(in) :: winsize The size of the window (segment).  If this value is less than N, the \nend of the segment will be padded with zeros. real(kind=real64), intent(out) :: buffer (:) A winsize array where the segment will be written. public pure subroutine unpack_real_transform (x, cx, fac) Unpacks a real-valued transform into its complex-valued format. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x (:) The complex-valued signal stored in a real-valued array.  This array\nis assumed to be of length N. complex(kind=real64), intent(out) :: cx (:) The M-element array where the complex form of x is written.  M is\ndetermined by calling compute_transform_length(N). real(kind=real64), intent(in), optional :: fac An optional scaling input.  The default is 1 such that no scaling\nis performed. public  subroutine unwrap (x, tol) Shifts phase angle arrays to deal with jumps greater than or equal\nto tol by adding multiples of until\nthe jump is less than tol. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: x (:) On input, the phase array.  On output, the unwrapped phase array. real(kind=real64), intent(in), optional :: tol The tolerance value.","tags":"","loc":"module\\spectrum_routines.html"},{"title":"spectrum_tf – SPECTRUM","text":"Uses iso_fortran_env ferror spectrum_periodogram spectrum_errors spectrum_windows Contents Variables SPCTRM_H1_ESTIMATOR SPCTRM_H2_ESTIMATOR Functions siso_transfer_function Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: SPCTRM_H1_ESTIMATOR = 50002 A flag for requesting an H1 transfer function estimator.  An H1 \nestimator is best used when noise is uncorrelated with the input, \nand results in a transfer function estimate of the form . integer(kind=int32), public, parameter :: SPCTRM_H2_ESTIMATOR = 50003 A flag for requesting an H2 transfer function estimator.  An H2 \nestimator is best used when noise is uncorrelated with the output, \nand results in a transfer function estimate of the form . Functions public  function siso_transfer_function (win, x, y, etype, nfft, err) result(rst) Estimates the transfer function for a single-input/single-output\n(SISO) system. Arguments Type Intent Optional Attributes Name class( window ), intent(in) :: win The window object. real(kind=real64), intent(in) :: x (:) An N-element array containing the input signal. real(kind=real64), intent(in) :: y (:) An N-element array containing the output signal. integer(kind=int32), intent(in), optional :: etype An optional input that, if supplied, denotes the\nestimator to use.  If no value is specified, an H1 estimator is used.\nThe following options are supported. Read more… integer(kind=int32), intent(in), optional :: nfft An optional input that can be used to force the length of each\nindividual DFT operation by padding any remaining space with zeros.\nIf not supplied, the window size is used to determine the size of\nthe DFT. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided can\nbe used to retrieve information relating to any errors encountered \nduring execution.  If not provided, a default implementation of the \nerrors class is used internally to provide error handling.  Possible \nerrors and warning messages that may be encountered are as follows. Read more… Return Value complex(kind=real64), allocatable, (:) Returns the complex-valued transfer function estimate.","tags":"","loc":"module\\spectrum_tf.html"},{"title":"spectrum_windows – SPECTRUM","text":"Uses iso_fortran_env Contents Interfaces window_function Derived Types blackman_harris_window flat_top_window hamming_window hann_window rectangular_window welch_window window Interfaces interface public pure function window_function(this, bin) result(rst) Evaluates the window function. Arguments Type Intent Optional Attributes Name class( window ), intent(in) :: this The window object. integer(kind=int32), intent(in) :: bin The index or bin number [0, n], where n is the window size. Return Value real(kind=real64) The function value. Derived Types type, public, extends( window ) :: blackman_harris_window Defines a Blackman-Harris window. Read more… Components Type Visibility Attributes Name Initial integer(kind=int32), public :: size = 0 The window size. Type-Bound Procedures procedure\n                    ,                  public\n                  :: evaluate =>\n                    bhw_eval Function type, public, extends( window ) :: flat_top_window Defines a flat-top window. Read more… Components Type Visibility Attributes Name Initial integer(kind=int32), public :: size = 0 The window size. Type-Bound Procedures procedure\n                    ,                  public\n                  :: evaluate =>\n                    ftw_eval Function type, public, extends( window ) :: hamming_window Defines a Hamming window. Read more… Components Type Visibility Attributes Name Initial integer(kind=int32), public :: size = 0 The window size. Type-Bound Procedures procedure\n                    ,                  public\n                  :: evaluate =>\n                    hamming_eval Function type, public, extends( window ) :: hann_window Defines a Hann window. Read more… Components Type Visibility Attributes Name Initial integer(kind=int32), public :: size = 0 The window size. Type-Bound Procedures procedure\n                    ,                  public\n                  :: evaluate =>\n                    hann_eval Function type, public, extends( window ) :: rectangular_window @brief Defines a rectangular window.\nDefines a rectangular window. Components Type Visibility Attributes Name Initial integer(kind=int32), public :: size = 0 The window size. Type-Bound Procedures procedure\n                    ,                  public\n                  :: evaluate =>\n                    rw_eval Function type, public, extends( window ) :: welch_window Defines a Welch window. Read more… Components Type Visibility Attributes Name Initial integer(kind=int32), public :: size = 0 The window size. Type-Bound Procedures procedure\n                    ,                  public\n                  :: evaluate =>\n                    welch_eval Function type, public :: window Defines the structure of a window. Components Type Visibility Attributes Name Initial integer(kind=int32), public :: size = 0 The window size. Type-Bound Procedures procedure\n(window_function)                    ,                  public\n, pass                  :: evaluate","tags":"","loc":"module\\spectrum_windows.html"},{"title":"spectrum.f90 – SPECTRUM","text":"Contents Modules spectrum Source Code spectrum.f90 Source Code module spectrum use spectrum_windows use spectrum_routines use spectrum_periodogram use spectrum_fft use spectrum_convolve use spectrum_filter use spectrum_tf use spectrum_diff implicit none private ! SPECTRUM_WINDOWS.F90 public :: window public :: window_function public :: rectangular_window public :: hann_window public :: hamming_window public :: welch_window public :: blackman_harris_window public :: flat_top_window ! SPECTRUM_ROUTINES.F90 public :: compute_transform_length public :: frequency_bin_width public :: is_power_of_two public :: next_power_of_two public :: unpack_real_transform public :: cumulative_sum public :: unwrap public :: difference public :: compute_overlap_segment_count public :: overlap ! SPECTRUM_PERIODOGRAM.F90 public :: psd public :: csd public :: periodogram public :: cross_periodogram ! SPECTRUM_FFT.F90 public :: stft ! SPECTRUM_CONVOLVE.F90 public :: convolve public :: SPCTRM_FULL_CONVOLUTION public :: SPCTRM_CENTRAL_CONVOLUTION ! SPECTRUM_FITLER.F90 public :: gaussian_filter public :: tv_filter public :: filter public :: moving_average_filter ! SPECTRUM_TF.F90 public :: siso_transfer_function public :: SPCTRM_H1_ESTIMATOR public :: SPCTRM_H2_ESTIMATOR ! SPECTRUM_DIFF.F90 public :: finite_difference public :: tvr_derivative public :: stencil_diff_5 end module","tags":"","loc":"sourcefile\\spectrum.f90.html"},{"title":"spectrum_convolve.f90 – SPECTRUM","text":"Contents Modules spectrum_convolve Source Code spectrum_convolve.f90 Source Code module spectrum_convolve use iso_fortran_env use fftpack use ferror use spectrum_errors implicit none private public :: convolve public :: SPCTRM_FULL_CONVOLUTION public :: SPCTRM_CENTRAL_CONVOLUTION integer ( int32 ), parameter :: SPCTRM_FULL_CONVOLUTION = 50000 !! A flag for requesting a full convolution. integer ( int32 ), parameter :: SPCTRM_CENTRAL_CONVOLUTION = 50001 !! A flag for requesting the central portion of the convolution that is !! the same length as the input signal. contains ! ------------------------------------------------------------------------------ function convolve ( x , y , method , err ) result ( rst ) !! Computes the convolution of a signal and kernel. real ( real64 ), intent ( in ) :: x (:) !! The N-element signal. real ( real64 ), intent ( in ) :: y (:) !! The M-element kernel. integer ( int32 ), intent ( in ), optional :: method !! An optional input that dictates the expected !! convolution result.  The following options are available. !! !! - SPCTRM_FULL_CONVOLUTION: The full convolution results are provided, !!     including the portions polluted courtesy of the zero-padding and !!     the corresponding wrap-around effects.  The length of this output !!     is N + M - 1. !! !!   SPCTRM_CENTRAL_CONVOLUTION: The N-element result containing the !!     convolved signal not poluted by the zero-padding and !!     corresponding wrap-around effects. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided can !! be used to retrieve information relating to any errors encountered !! during execution.  If not provided, a default implementation of the !! errors class is used internally to provide error handling.  Possible !! errors and warning messages that may be encountered are as follows. !! !!  - SPCTRM_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory !!      available. real ( real64 ), allocatable :: rst (:) !! The convolved result. ! Local Variables integer ( int32 ) :: mth , n1 , n2 real ( real64 ), allocatable :: temp (:) complex ( real64 ), allocatable :: xmod (:), ymod (:) class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( present ( method )) then mth = method else mth = SPCTRM_FULL_CONVOLUTION end if ! Input Checking if ( mth /= SPCTRM_FULL_CONVOLUTION . and . & mth /= SPCTRM_CENTRAL_CONVOLUTION ) & then ! Reset mth = SPCTRM_FULL_CONVOLUTION end if ! Prepare the signals call prepare_conv ( x , y , xmod , ymod , n1 , n2 , errmgr ) if ( errmgr % has_error_occurred ()) return ! Compute the convolution if ( mth == SPCTRM_CENTRAL_CONVOLUTION ) then call convolve_driver ( xmod , ymod , 1 , temp , errmgr ) if ( errmgr % has_error_occurred ()) return rst = temp ( n1 : n2 ) else call convolve_driver ( xmod , ymod , 1 , rst , errmgr ) end if end function ! ------------------------------------------------------------------------------ ! Prepares two signals for convolution. ! ! - x: The original signal of length N. ! - y: The original response signal of length M where M <= N. ! - xmod: The padded X signal of length M + N - 1. ! - ymod: The padded Y signal of length M + N - 1. ! - n2: The ending index of the unspoiled data subroutine prepare_conv ( x , y , xmod , ymod , n1 , n2 , err ) ! Arguments real ( real64 ), intent ( in ) :: x (:), y (:) complex ( real64 ), intent ( out ), allocatable :: xmod (:), ymod (:) integer ( int32 ), intent ( out ) :: n1 , n2 class ( errors ), intent ( inout ) :: err ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: nx , ny , n , nbig , dn , m , flag logical :: evenY character ( len = :), allocatable :: errmsg ! Initialization nx = size ( x ) ny = size ( y ) n = nx + ny - 1 ! Memory Allocation allocate ( xmod ( n ), stat = flag , source = zero ) if ( flag == 0 ) allocate ( ymod ( n ), stat = flag , source = zero ) if ( flag /= 0 ) then ! ERROR: allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) \"Memory allocation error flag \" , flag , \".\" call err % report_error ( \"prepare_conv\" , trim ( errmsg ), & SPCTRM_MEMORY_ERROR ) end if ! Copy over X & Y if ( nx >= ny ) then xmod ( 1 : nx ) = cmplx ( x , 0.0d0 , real64 ) ymod ( 1 : ny ) = cmplx ( y , 0.0d0 , real64 ) nbig = nx else xmod ( 1 : ny ) = cmplx ( y , 0.0d0 , real64 ) ymod ( 1 : nx ) = cmplx ( x , 0.0d0 , real64 ) nbig = ny end if ! Locate the unspoiled data points dn = n - nbig if ( mod ( dn , 2 ) == 0 ) then n1 = dn / 2 + 1 else n1 = ( dn + 1 ) / 2 + 1 end if n2 = n1 + nbig - 1 ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ ! Computes the convolution or deconvolution of two signals. ! ! - x: The zero-padded original signal. ! - y: The padded and wrapped response signal. ! - method: +1 for convolution, -1 for deconvolution. ! - rst: The convolved signal. ! - err: An error handling object. subroutine convolve_driver ( x , y , method , rst , err ) ! Arguments complex ( real64 ), intent ( inout ) :: x (:), y (:) integer ( int32 ), intent ( in ) :: method real ( real64 ), intent ( out ), allocatable :: rst (:) class ( errors ), intent ( inout ) :: err ! Local Variables integer ( int32 ) :: i , n , lwork , flag , nend real ( real64 ) :: fac real ( real64 ), allocatable , dimension (:) :: work complex ( real64 ), allocatable , dimension (:) :: cxy character ( len = :), allocatable :: errmsg ! Generate the workspace array for the transforms & allocate memory n = size ( x ) lwork = 4 * n + 15 allocate ( work ( lwork ), stat = flag ) if ( flag == 0 ) allocate ( rst ( n ), stat = flag ) if ( flag /= 0 ) then ! ERROR: allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) \"Memory allocation error flag \" , flag , \".\" call err % report_error ( \"convolve_driver\" , trim ( errmsg ), & SPCTRM_MEMORY_ERROR ) end if ! Compute the FFT's of both signals call zffti ( n , work ) call zfftf ( n , x , work ) call zfftf ( n , y , work ) ! Compute the scaling factor fac = 1.0d0 / real ( n , real64 ) ! Perform the convolution operation if ( method == 1 ) then ! Multiply the FFT's to convolve cxy = x * y else ! Divide the FFT's to deconvolve cxy = x / y end if ! Compute the inverse transform call zfftb ( n , cxy , work ) if ( method == 1 ) then rst = real ( fac * cxy ) else rst = real ( cxy ) end if ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\spectrum_convolve.f90.html"},{"title":"spectrum_diff.f90 – SPECTRUM","text":"Contents Modules spectrum_diff Source Code spectrum_diff.f90 Source Code ! REF: ! - https://ejde.math.txstate.edu/conf-proc/21/k3/knowles.pdf ! - https://arxiv.org/pdf/2009.01911.pdf module spectrum_diff use iso_fortran_env use blas use linalg use ferror use spectrum_errors implicit none private public :: finite_difference public :: tvr_derivative public :: stencil_diff_5 interface finite_difference module procedure :: finite_difference_1 module procedure :: finite_difference_2 end interface interface finite_difference_driver module procedure :: finite_difference_driver_1 module procedure :: finite_difference_driver_2 end interface ! BLAS Routines: interface ! subroutine dgbmv(trans, m, n, kl, ku, alpha, a, lda, x, incx, beta, y, incy) !     use iso_fortran_env, only : int32, real64 !     character, intent(in) :: trans !     integer(int32), intent(in) :: m, n, kl, ku, lda, incx, incy !     real(real64), intent(in) :: alpha, beta, a(lda,*), x(*) !     real(real64), intent(inout) :: y(*) ! end subroutine ! subroutine dgemm(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) !     use iso_fortran_env, only : int32, real64 !     character, intent(in) :: transa, transb !     integer(int32), intent(in) :: m, n, k, lda, ldb, ldc !     real(real64), intent(in) :: alpha, beta, a(lda,*), b(ldb,*) !     real(real64), intent(inout) :: c(ldc,*) ! end subroutine ! subroutine dgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy) !     use iso_fortran_env, only : int32, real64 !     character, intent(in) :: trans !     integer(int32), intent(in) :: m, n, lda, incx, incy !     real(real64), intent(in) :: alpha, beta, a(lda,*), x(*) !     real(real64), intent(inout) :: y(*) ! end subroutine subroutine dgesv ( n , nrhs , a , lda , ipiv , b , ldb , info ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: n , nrhs , lda , ldb real ( real64 ), intent ( inout ) :: a ( lda , * ), b ( ldb , * ) integer ( int32 ), intent ( out ) :: ipiv ( * ), info end subroutine end interface contains ! ------------------------------------------------------------------------------ pure subroutine finite_difference_driver_1 ( dt , x , dxdt ) ! Arguments real ( real64 ), intent ( in ) :: dt real ( real64 ), intent ( in ), dimension (:) :: x real ( real64 ), intent ( out ), dimension (:) :: dxdt ! Local Variables integer ( int32 ) :: i , n ! Process n = size ( x ) if ( n == 0 ) return if ( n == 1 ) then dxdt = 0.0d0 return end if dxdt ( 1 ) = ( x ( 2 ) - x ( 1 )) / dt do i = 2 , n - 1 dxdt ( i ) = 0.5d0 * ( x ( i + 1 ) - x ( i - 1 )) / dt end do dxdt ( n ) = ( x ( n ) - x ( n - 1 )) / dt end subroutine ! ------------------------------------------------------------------------------ pure subroutine finite_difference_driver_2 ( t , x , dxdt ) ! Arguments real ( real64 ), intent ( in ), dimension (:) :: t , x real ( real64 ), intent ( out ), dimension (:) :: dxdt ! Local Variables integer ( int32 ) :: i , n ! Process n = size ( x ) if ( n == 0 ) return if ( n == 1 ) then dxdt = 0.0d0 return end if dxdt ( 1 ) = ( x ( 2 ) - x ( 1 )) / ( t ( 2 ) - t ( 1 )) do i = 2 , n - 1 dxdt ( i ) = 0.5d0 * ( x ( i + 1 ) - x ( i - 1 )) / ( t ( i + 1 ) - t ( i - 1 )) end do dxdt ( n ) = ( x ( n ) - x ( n - 1 )) / ( t ( n ) - t ( n - 1 )) end subroutine ! ------------------------------------------------------------------------------ function finite_difference_1 ( dt , x , err ) result ( rst ) !! Estimates the derivative of a data set by means of a naive !! implementation of a finite difference scheme based upon central !! differences. real ( real64 ), intent ( in ) :: dt !! The time step between data points. real ( real64 ), intent ( in ), dimension (:) :: x !! An N-element array containing the data whose derivative is to be !! estimated. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided can !! be used to retrieve information relating to any errors encountered !! during execution.  If not provided, a default implementation of the !! errors class is used internally to provide error handling.  Possible !! errors and warning messages that may be encountered are as follows. !! !!  - SPCTRM_MEMORY_ERROR: Occurs if a memory allocation error occurs. real ( real64 ), allocatable , dimension (:) :: rst !! An N-element array containing the derivative estimate. ! Local Variables integer ( int32 ) :: n , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if n = size ( x ) allocate ( rst ( n ), stat = flag ) if ( flag /= 0 ) then call errmgr % report_error ( \"finite_difference_1\" , & \"Memory allocation error.\" , SPCTRM_MEMORY_ERROR ) return end if ! Process call finite_difference_driver ( dt , x , rst ) end function ! ------------------------------------------------------------------------------ function finite_difference_2 ( t , x , err ) result ( rst ) !! Computes an estimate to the derivative of an evenly-sampled data !! set using total variation regularization. real ( real64 ), intent ( in ), dimension (:) :: t !! An N-element array containing the time points at which x was sampled. real ( real64 ), intent ( in ), dimension (:) :: x !! An N-element array containing the data whose derivative is to be !! estimated. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided can !! be used to retrieve information relating to any errors encountered !! during execution.  If not provided, a default implementation of the !! errors class is used internally to provide error handling.  Possible !! errors and warning messages that may be encountered are as follows. !! !!  - SPCTRM_MEMORY_ERROR: Occurs if a memory allocation error occurs. !! !!  - SPCTRM_ARRAY_SIZE_MISMATCH_ERROR: Occurs if t and x are not the !!      same size. real ( real64 ), allocatable , dimension (:) :: rst !! An N-element array containing the derivative estimate. ! Local Variables integer ( int32 ) :: n , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if n = size ( t ) ! Input Checking if ( size ( x ) /= n ) then call errmgr % report_error ( \"finite_difference_2\" , & \"The input arrays must be the same size.\" , SPCTRM_ARRAY_SIZE_ERROR ) return end if ! Memory Allocation allocate ( rst ( n ), stat = flag ) if ( flag /= 0 ) then call errmgr % report_error ( \"finite_difference_2\" , & \"Memory allocation error.\" , SPCTRM_MEMORY_ERROR ) return end if ! Process call finite_difference_driver ( t , x , rst ) end function ! ****************************************************************************** ! TOTAL VARIATION REGULARIZATION ! ------------------------------------------------------------------------------ ! REF: https://oliver-k-ernst.medium.com/how-to-differentiate-noisy-signals-2baf71b8bb65 ! https://github.com/smrfeld/Total-Variation-Regularization-Derivative-Python/blob/main/python/diff_tvr.py ! https://github.com/florisvb/PyNumDiff/blob/master/pynumdiff/total_variation_regularization/__chartrand_tvregdiff__.py ! Constructs the N-by-N+1 D matrix: !          | -1     1         | ! D = 1/dx |  0     -1      1 | !          |  0     0      -1 | subroutine make_d_full ( dx , d ) ! Arguments real ( real64 ), intent ( in ) :: dx real ( real64 ), intent ( out ), dimension (:,:) :: d ! Local Variables integer ( int32 ) :: j , n real ( real64 ) :: idx ! Process n = size ( d , 1 ) idx = 1.0d0 / dx d = 0.0d0 do j = 1 , n + 1 if ( j > 1 ) d ( j - 1 , j ) = idx if ( j <= n ) d ( j , j ) = - idx end do end subroutine ! ------------------------------------------------------------------------------ ! Constructs the N-by-N+1 A matrix. subroutine make_a_full ( dx , a ) ! Arguments real ( real64 ), intent ( in ) :: dx real ( real64 ), intent ( out ), dimension (:,:) :: a ! Local Variables integer ( int32 ) :: j , n real ( real64 ) :: hdx ! Process n = size ( a , 1 ) hdx = 0.5d0 * dx do j = 1 , n + 1 if ( j == 1 ) then a (:, j ) = hdx else if ( j > 1 ) a ( j - 1 , j ) = hdx if ( j <= n ) a ( j :, j ) = dx end if end do end subroutine ! ------------------------------------------------------------------------------ ! Constructs the N-by-N E matrix.  The matrix is a diagonal matrix with only the ! diagonal stored. subroutine make_e ( d , u , e ) ! Arguments real ( real64 ), intent ( in ), dimension (:,:) :: d real ( real64 ), intent ( in ), dimension (:) :: u real ( real64 ), intent ( out ), dimension (:) :: e ! Local Variables integer ( int32 ) :: j , n , n1 real ( real64 ) :: eps ! Process eps = sqrt ( epsilon ( eps )) n = size ( d , 1 ) n1 = n + 1 call dgemv ( \"N\" , n , n1 , 1.0d0 , d , n , u , 1 , 0.0d0 , e , 1 ) do j = 1 , n e ( j ) = 1.0d0 / sqrt ( e ( j ) ** 2 + eps ) end do end subroutine ! ------------------------------------------------------------------------------ subroutine tvr_diff_small ( alpha , dt , x , maxiter , dxdt , tol , niter , err ) real ( real64 ), intent ( in ) :: alpha ! variational parameter real ( real64 ), intent ( in ) :: dt ! time step real ( real64 ), intent ( in ), dimension (:) :: x ! data array to differentiate integer ( int32 ), intent ( in ) :: maxiter ! max # of iterations real ( real64 ), intent ( out ), dimension (:) :: dxdt ! derivative dx/dt real ( real64 ), intent ( in ) :: tol ! tolerance on change in gradient integer ( int32 ), intent ( out ) :: niter ! # of iterations taken class ( errors ), intent ( inout ) :: err ! Local Variables integer ( int32 ) :: i , n , n1 , flag integer ( int32 ), allocatable , dimension (:) :: ipiv real ( real64 ) :: offset , nrm , nrmold real ( real64 ), allocatable , dimension (:,:) :: d , a , dte , l , ata , h real ( real64 ), allocatable , dimension (:) :: e , u , atb , atau , lu , g ! Initialization n = size ( x ) n1 = n + 1 nrmold = huge ( nrmold ) ! Memory Allocations allocate ( & d ( n , n1 ), & a ( n , n1 ), & e ( n ), & u ( n1 ), & atb ( n ), & dte ( n1 , n ), & l ( n1 , n1 ), & ata ( n1 , n1 ), & atau ( n1 ), & lu ( n1 ), & g ( n1 ), & h ( n1 , n1 ), & ipiv ( n1 ), & stat = flag ) if ( flag /= 0 ) go to 10 ! Construct matrices call make_d_full ( dt , d ) call make_a_full ( dt , a ) call dgemm ( \"T\" , \"N\" , n1 , n1 , n , 1.0d0 , a , n , a , n , 0.0d0 , ata , n1 ) ! A**T * A ! Provide a first estimate of the derivative u ( 1 ) = 0.0d0 u ( 2 :) = finite_difference ( dt , x ) ! Precompute A**T * (X(1) - X) call dgemv ( \"T\" , n , n1 , 1.0d0 , a , n , offset - x , 1 , 0.0d0 , atb , 1 ) ! Iteration Process do i = 1 , maxiter ! Compute E and L call make_e ( d , u , e ) call diag_mtx_mult (. false ., . true ., dt , e , d , 0.0d0 , dte ) ! dt * D**T * E call dgemm ( \"N\" , \"N\" , n1 , n1 , n , 1.0d0 , dte , n1 , d , n , 0.0d0 , l , n1 ) ! L = (dx * D**T * E) * D ! Compute the gradient call dgemv ( \"N\" , n1 , n1 , 1.0d0 , ata , n1 , u , 1 , 0.0d0 , atau , 1 ) call dgemv ( \"N\" , n1 , n1 , alpha , l , n1 , u , 1 , 0.0d0 , lu , 1 ) g = atau + atb + lu ! Compute H h = ata + alpha * l ! Solve H * s = g, for s - stored in g call dgesv ( n1 , 1 , h , n1 , ipiv , g , n1 , flag ) if ( flag /= 0 ) go to 20 ! Check the solution nrm = norm2 ( g ) if ( abs ( nrm - nrmold ) < tol ) exit nrmold = nrm ! Update the derivative estimate u = u - g end do niter = min ( i , maxiter ) ! Extract the computed derivative dxdt = u ( 1 : n ) ! End return ! Memory Error 10 continue call err % report_error ( \"tvr_diff_small\" , \"Memory allocation error.\" , & SPCTRM_MEMORY_ERROR ) return ! Solution Error - Singular matrix 20 continue call err % report_error ( \"tvr_diff_small\" , \"A singular Hessian matrix \" // & \"was encountered.  Check to ensure the problem is properly defined.\" , & SPCTRM_SINGULAR_MATRIX_ERROR ) return end subroutine ! ------------------------------------------------------------------------------ function tvr_derivative ( dt , x , alpha , maxiter , tol , niter , err ) result ( rst ) !! Computes an estimate to the derivative of an evenly-sampled data !! set using total variation regularization. !! !! See Also !! !! - van Breugel, Floris & Brunton, Bingni & Kutz, J.. (2020). Numerical !!   differentiation of noisy data: A unifying multi-objective optimization !!   framework. !! !! - Oliver K. Ernst, Ph. D. (2021, February 16). How to differentiate !!   noisy signals. Medium. https://oliver-k-ernst.medium.com/how-to-differentiate-noisy-signals-2baf71b8bb65 real ( real64 ), intent ( in ) :: dt !! The time step between data points. real ( real64 ), intent ( in ), dimension (:) :: x !! An N-element array containing the data whose derivative is !! to be estimated. real ( real64 ), intent ( in ) :: alpha !! The regularization parameter. integer ( int32 ), intent ( in ), optional :: maxiter !! The maximum number of iterations to allow.  The default is 20 !! iterations. real ( real64 ), intent ( in ), optional :: tol !! The convergence tolerance to use.  The tolerance is !! applied to the difference in Euclidean norms of the derivative update !! vector.  Once the norm of the update vector is changing less than !! this tolerance, the iteration process will terminate.  The default !! is 1e-3. integer ( int32 ), intent ( out ), optional :: niter !! The number of iterations actually performed. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided can !! be used to retrieve information relating to any errors encountered !! during execution.  If not provided, a default implementation of the !! errors class is used internally to provide error handling.  Possible !! errors and warning messages that may be encountered are as follows. !! !!  - SPCTRM_MEMORY_ERROR: Occurs if a memory allocation error occurs. !! !!  - SPCTRM_SINGULAR_MATRIX_ERROR: Occurs if the internal Hessian !!      estimate becomes singular. real ( real64 ), allocatable , dimension (:) :: rst !! An N-element array containing the estimate of the derivative. ! Local Variables integer ( int32 ) :: mi , n , flag , ni real ( real64 ) :: gtol class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( present ( maxiter )) then mi = maxiter else mi = 20 end if if ( present ( tol )) then gtol = tol else gtol = 1.0d-3 end if n = size ( x ) allocate ( rst ( n ), stat = flag ) if ( flag /= 0 ) then call errmgr % report_error ( \"tvr_derivative\" , \"Memory allocation error.\" , & SPCTRM_MEMORY_ERROR ) return end if ! Process call tvr_diff_small ( alpha , dt , x , mi , rst , gtol , ni , errmgr ) if ( present ( niter )) niter = ni end function ! ****************************************************************************** ! V1.1.2 ADDITIONS ! ------------------------------------------------------------------------------ function stencil_diff_5 ( dt , x , err ) result ( rst ) !! Utilizes a 5-point stencil to estimate the derivative of a data set. !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Five-point_stencil) real ( real64 ), intent ( in ) :: dt !! The time step between data points. real ( real64 ), intent ( in ), dimension (:) :: x !! An N-element array containing the data whose derivative is to be !! estimated. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided can !! be used to retrieve information relating to any errors encountered !! during execution.  If not provided, a default implementation of the !! errors class is used internally to provide error handling.  Possible !! errors and warning messages that may be encountered are as follows. !! !!  - SPCTRM_MEMORY_ERROR: Occurs if a memory allocation error occurs. real ( real64 ), allocatable , dimension (:) :: rst !! An N-element array containing the derivative estimate. ! Local Variables integer ( int32 ) :: i , n , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if n = size ( x ) allocate ( rst ( n ), stat = flag ) if ( flag /= 0 ) then call errmgr % report_error ( \"stencil_diff_5\" , & \"Memory allocation error.\" , SPCTRM_MEMORY_ERROR ) return end if ! Process ! Step in and out of the problem via finite differences; else, use ! a 5-point stencil of the form: ! ! f'(x) = (-f(x+2h) + 8f(x+h) - 8f(x-h) + f(x-2h)) / (12h) rst ( 1 ) = ( x ( 2 ) - x ( 1 )) / dt rst ( 2 ) = ( x ( 3 ) - x ( 2 )) / dt do i = 3 , n - 2 rst ( i ) = ( - x ( i + 2 ) + 8.0d0 * ( x ( i + 1 ) - x ( i - 1 )) + x ( i - 2 )) / & ( 1 2.0d0 * dt ) end do rst ( n - 1 ) = ( x ( n - 1 ) - x ( n - 2 )) / dt rst ( n ) = ( x ( n ) - x ( n - 1 )) / dt end function ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\spectrum_diff.f90.html"},{"title":"spectrum_errors.f90 – SPECTRUM","text":"Contents Modules spectrum_errors Source Code spectrum_errors.f90 Source Code module spectrum_errors use iso_fortran_env implicit none integer ( int32 ), parameter :: SPCTRM_MEMORY_ERROR = 10000 integer ( int32 ), parameter :: SPCTRM_INVALID_INPUT_ERROR = 10001 integer ( int32 ), parameter :: SPCTRM_ARRAY_SIZE_MISMATCH_ERROR = 10002 integer ( int32 ), parameter :: SPCTRM_ARRAY_SIZE_ERROR = 10003 integer ( int32 ), parameter :: SPCTRM_SINGULAR_MATRIX_ERROR = 10004 end module","tags":"","loc":"sourcefile\\spectrum_errors.f90.html"},{"title":"spectrum_fft.f90 – SPECTRUM","text":"Contents Modules spectrum_fft Source Code spectrum_fft.f90 Source Code module spectrum_fft use iso_fortran_env use fftpack use spectrum_windows use spectrum_routines use ferror use spectrum_errors implicit none private public :: stft contains ! ------------------------------------------------------------------------------ function stft ( win , x , offsets , err ) result ( rst ) !! Computes the short time Fourier transform of a signal. !! !! See Also !! !! - [Wikipedia - Short Time Fourier Transform](https://en.wikipedia.org/wiki/Short-time_Fourier_transform) class ( window ), intent ( in ) :: win !! The window to apply. real ( real64 ), intent ( in ) :: x (:) !! The signal to analyze.  The signal must be longer than the size of !! the window. integer ( int32 ), intent ( out ), optional , allocatable :: offsets (:) !! An optional allocatable array that, if supplied, will be filled with !! the starting indices of each window segment. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided can !! be used to retrieve information relating to any errors encountered !! during execution.  If not provided, a default implementation of the !! errors class is used internally to provide error handling.  Possible !! errors and warning messages that may be encountered are as follows. !! !!  - SPCTRM_MEMORY_ERROR: Occurs if a memory allocation error occurs. !! !!  - SPCTRM_INVALID_INPUT_ERROR: Occurs if the signal in x is too short !!      relative to the window size in win. complex ( real64 ), allocatable :: rst (:,:) !! An M-by-N matrix containing the M-element complex-valued !! transforms for each of the N time points studied.  M is the size of !! the positive half of the transform, and N is the total number of !! transformed segments. ! Local Variables integer ( int32 ) :: i , j , k , m , nx , nxfrm , nk , lwork , flag , i1 , nend real ( real64 ) :: del , sumw , w , fac , scale real ( real64 ), allocatable , dimension (:) :: work , buffer class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if nx = size ( x ) m = win % size ! # of rows in the output matrix (transform length) nxfrm = compute_transform_length ( m ) lwork = 2 * m + 15 nk = compute_overlap_segment_count ( nx , m ) if ( nk > 1 ) then del = ( nx - m ) / ( nk - 1.0d0 ) else del = 0.0d0 end if if ( mod ( m , 2 ) == 0 ) then nend = nxfrm - 1 scale = 2.0d0 / m else nend = nxfrm scale = 2.0d0 / ( m - 1.0d0 ) end if ! Input Checking if ( m > nx ) go to 20 ! Memory Allocation allocate ( rst ( nxfrm , nk ), stat = flag ) if ( flag == 0 ) allocate ( work ( lwork ), stat = flag ) if ( flag == 0 ) allocate ( buffer ( m ), stat = flag ) if ( present ( offsets )) then if ( flag == 0 ) allocate ( offsets ( nk ), stat = flag , source = 0 ) end if if ( flag /= 0 ) go to 10 ! Initialize the trig terms for the transforms.  As all transforms are the ! same length, this array can be shared. call dffti ( m , work ) ! Compute each transform do i = 1 , nk ! Compute the offset i1 = int (( i - 1 ) * del + 0.5d0 , int32 ) if ( present ( offsets )) offsets ( i ) = i1 + 1 ! Apply the window sumw = 0.0d0 j = 0 do k = 1 , m w = win % evaluate ( j ) j = j + 1 sumw = sumw + w buffer ( k ) = w * x ( k + i1 ) end do fac = m / sumw ! Compute the transform call dfftf ( m , buffer , work ) ! Scale the transform rst ( 1 , i ) = fac * scale * cmplx ( buffer ( 1 ), 0.0d0 , real64 ) do k = 2 , nend rst ( k , i ) = fac * scale * cmplx ( buffer ( 2 * k - 1 ), buffer ( 2 * k ), real64 ) end do if ( nend /= nxfrm ) then rst ( nxfrm , i ) = fac * scale * cmplx ( buffer ( m ), 0.0d0 , real64 ) end if end do ! End return ! Memory Error Handling 10 continue allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) \"Memory allocation error flag \" , flag , \".\" call errmgr % report_error ( \"stft\" , trim ( errmsg ), & SPCTRM_MEMORY_ERROR ) return ! Window size exceeds signal length 20 continue allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 101 ) \"Window size (\" , m , \") exceeds the signal length (\" , & nx , \").\" call errmgr % report_error ( \"stft\" , trim ( errmsg ), SPCTRM_INVALID_INPUT_ERROR ) return ! Formatting 100 format ( A , I0 , A ) 101 format ( A , I0 , A , I0 , A ) end function ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\spectrum_fft.f90.html"},{"title":"spectrum_filter.f90 – SPECTRUM","text":"Contents Modules spectrum_filter Source Code spectrum_filter.f90 Source Code module spectrum_filter use iso_fortran_env use ferror use spectrum_errors use spectrum_convolve use spectrum_routines implicit none private public :: gaussian_filter public :: tv_filter public :: filter public :: moving_average_filter contains ! ****************************************************************************** ! GAUSSIAN FILTER ! ------------------------------------------------------------------------------ function gaussian_filter ( x , alpha , k , err ) result ( rst ) !! Applies a Gaussian filter to a signal. real ( real64 ), intent ( in ) :: x (:) !! An N-element array containing the signal to filter. real ( real64 ), intent ( in ) :: alpha !! A parameter that specifies the number of standard deviations !!  \\sigma  desired in the kernel.  This parameter is related to the !! standard deviation by  \\sigma = \\frac{k - 1}{2 \\alpha} . integer ( int32 ), intent ( in ) :: k !! The kernel size.  This value must be a positive, non-zero !! integer value less than N. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided can !! be used to retrieve information relating to any errors encountered !! during execution.  If not provided, a default implementation of the !! errors class is used internally to provide error handling.  Possible !! errors and warning messages that may be encountered are as follows. !! !!  - SPCTRM_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory !!      available. !! !!  - SPCTRM_INVALID_INPUT_ERROR: Occurs if k is not within the proper !!      bounds. real ( real64 ), allocatable :: rst (:) !! An N-element array containing the filtered signal. ! Local Variables integer ( int32 ) :: i , kappa , nk , flag real ( real64 ) :: sumg real ( real64 ), allocatable :: g (:) class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( mod ( k , 2 ) == 0 ) then nk = k + 1 else nk = k end if kappa = - ( nk - 1 ) / 2 sumg = 0.0d0 ! Input Checking if ( nk > size ( x ) . or . k < 1 ) go to 20 if ( alpha <= 0.0d0 ) go to 30 ! Memory Allocation allocate ( g ( nk ), stat = flag ) if ( flag /= 0 ) go to 10 ! Define the kernel do i = 1 , nk g ( i ) = exp ( - 0.5d0 * ( 2.0d0 * alpha * kappa / ( nk - 1.0d0 )) ** 2 ) kappa = kappa + 1 sumg = sumg + g ( i ) end do ! Normalize the kernel to have a sum of one g = g / sumg ! Compute the convolution and keep only the non-poluted data rst = convolve ( x , g , SPCTRM_CENTRAL_CONVOLUTION , err = errmgr ) ! End return ! Memory Error Handling 10 continue allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) \"Memory allocation error flag \" , flag , \".\" call errmgr % report_error ( \"gaussian_filter\" , trim ( errmsg ), & SPCTRM_MEMORY_ERROR ) return ! Kernel Size Error 20 continue call errmgr % report_error ( \"gaussian_filter\" , \"The kernel size must \" // & \"be a positive valued integer less than the size of the signal \" // & \"being filtered.\" , SPCTRM_INVALID_INPUT_ERROR ) return ! Invalid Kernel Parameter 30 continue call errmgr % report_error ( \"gaussian_filter\" , \"The kernal parameter \" // & \"alpha must be positive-valued.\" , SPCTRM_INVALID_INPUT_ERROR ) return ! Formatting 100 format ( A , I0 , A ) 101 format ( A ) end function ! ****************************************************************************** ! TOTAL VARIATION FILTERING ! ------------------------------------------------------------------------------ ! REF: ! https://eeweb.engineering.nyu.edu/iselesni/lecture_notes/TV_filtering.pdf function tv_filter ( x , lambda , niter , err ) result ( rst ) !! Applies a total-variation filter to a signal. !! !! The algorithm used by this routine is based upon the algorithm presented !! by [Selesnick and Bayram] !! (https://eeweb.engineering.nyu.edu/iselesni/lecture_notes/TV_filtering.pdf). real ( real64 ), intent ( in ) :: x (:) !! An N-element array containing the signal to filter. real ( real64 ), intent ( in ) :: lambda !! The regularization parameter.  The actual value to use !! is problem dependent, but the noisier the data, the larger this value !! should be.  A good starting point is typically 0.3 - 0.5; however, the !! actual value is problem dependent. integer ( int32 ), intent ( in ), optional :: niter !! An optional parameter controlling the number of iterations performed. !! The default limit is 10 iterations. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided can !! be used to retrieve information relating to any errors encountered !! during execution.  If not provided, a default implementation of the !! errors class is used internally to provide error handling.  Possible !! errors and warning messages that may be encountered are as follows. !! !!  - SPCTRM_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory !!      available. !! !!  - SPCTRM_INVALID_INPUT_ERROR: Occurs if niter is less than one. real ( real64 ), allocatable :: rst (:) !! An N-element array containing the filtered signal. ! Parameters real ( real64 ), parameter :: alpha = 4.0d0 ! Local Variables class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg integer ( int32 ) :: i , k , nit , n , flag real ( real64 ) :: t real ( real64 ), allocatable :: z (:), work (:), dx (:) ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( present ( niter )) then nit = niter else nit = 10 end if n = size ( x ) ! Input Checking if ( nit < 1 ) go to 20 ! Memory Allocations allocate ( rst ( n ), stat = flag ) if ( flag == 0 ) allocate ( z ( n - 1 ), stat = flag , source = 0.0d0 ) if ( flag == 0 ) allocate ( dx ( n - 1 ), stat = flag ) if ( flag == 0 ) allocate ( work ( n ), stat = flag ) if ( flag /= 0 ) go to 10 ! Process t = 0.5d0 * lambda do i = 1 , nit ! call difference(z, work(2:n-1)) work ( 2 : n - 1 ) = difference ( z ) work ( 1 ) = z ( 1 ) work ( n ) = - z ( n - 1 ) rst = x + work ! call difference(rst, dx) dx = difference ( rst ) do k = 1 , n - 1 z ( k ) = z ( k ) + dx ( k ) / alpha z ( k ) = max ( min ( z ( k ), t ), - t ) end do end do ! End return ! Memory Error 10 continue allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) \"Memory allocation error flag \" , flag , \".\" call errmgr % report_error ( \"tv_filter\" , trim ( errmsg ), & SPCTRM_MEMORY_ERROR ) return ! Invalid Input Error 20 continue call errmgr % report_error ( \"tv_filter\" , \"The number of input \" // & \"iterations must be at least 1.\" , SPCTRM_INVALID_INPUT_ERROR ) return ! Formatting 100 format ( A , I0 , A ) 101 format ( A ) end function ! ------------------------------------------------------------------------------ function filter ( b , a , x , delays , err ) result ( rst ) !! Applies the specified filter to a signal. !! !! The description of the filter in the Z-transform domain is a rational !! transfer function of the form: !! !!  Y(z) = \\frac{b(1) + b(2) z&#94;{-1} + ... + b(n_b + 1)z&#94;{-n_b}} !! {1 + a(2) z&#94;{-1} + ... + a(n_a + 1) z&#94;{-n_a}} X(z) , !! which handles both IIR and FIR filters. The above form assumes a !! normalization of a(1) = 1; however, the routine will appropriately !! handle the situation where a(1) is not set to one. real ( real64 ), intent ( in ) :: b (:) !! The numerator coefficients of the rational transfer function. real ( real64 ), intent ( in ) :: a (:) !! The denominator coefficients of the ration transfer function.  In !! the case of an FIR filter, this parameter should be set to a !! one-element array with a value of one.  Regardless, the value of !! a(1) must be non-zero. real ( real64 ), intent ( in ) :: x (:) !! An N-element array containing the signal to filter. real ( real64 ), intent ( inout ), optional , target :: delays (:) !! An optional array of length !! MAX(size(a), size(b)) - 1 that, on input, provides the initial !! conditions for filter delays, and on ouput, the final conditions for !! filter delays. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided can !! be used to retrieve information relating to any errors encountered !! during execution.  If not provided, a default implementation of the !! errors class is used internally to provide error handling.  Possible !! errors and warning messages that may be encountered are as follows. !! !!  - SPCTRM_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory !!      available. !! !!  - SPCTRM_INVALID_INPUT_ERROR: Occurs if a(1) is zero. !! !!  - SPCTRM_ARRAY_SIZE_ERROR: Occurs if a is not sized correctly, or if !!      delays is not sized correctly. real ( real64 ), allocatable :: rst (:) !! An N-element array containing the filtered signal. ! Parameters real ( real64 ), parameter :: tol = 2.0d0 * epsilon ( 2.0d0 ) ! Local Variables class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg integer ( int32 ) :: i , m , na , nb , n , nx , flag real ( real64 ), allocatable :: aa (:), bb (:) real ( real64 ), allocatable , target :: zdef (:) real ( real64 ), pointer :: zptr (:) ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if nx = size ( x ) na = size ( a ) nb = size ( b ) if ( na > nb ) then n = na else n = nb end if ! Input Checking if ( na < 1 ) go to 20 if ( abs ( a ( 1 )) < tol ) go to 30 ! Memory Allocations if ( present ( delays )) then if ( size ( delays ) /= n - 1 ) go to 40 zptr ( 1 : n - 1 ) => delays else allocate ( zdef ( n - 1 ), stat = flag , source = 0.0d0 ) if ( flag /= 0 ) go to 10 zptr ( 1 : n - 1 ) => zdef end if allocate ( aa ( n ), stat = flag , source = 0.0d0 ) if ( flag == 0 ) allocate ( bb ( n ), stat = flag , source = 0.0d0 ) if ( flag == 0 ) allocate ( rst ( nx ), stat = flag , source = 0.0d0 ) if ( flag /= 0 ) go to 10 ! Copy over A & B and scale such that A(1) = 1 if ( abs ( a ( 1 ) - 1.0d0 ) > tol ) then bb ( 1 : nb ) = b / a ( 1 ) aa ( 1 : na ) = a / a ( 1 ) else bb ( 1 : nb ) = b aa ( 1 : na ) = a end if ! Process if ( na > 1 ) then ! IIR do m = 1 , nx rst ( m ) = bb ( 1 ) * x ( m ) + zptr ( 1 ) do i = 2 , n - 1 zptr ( i - 1 ) = bb ( i ) * x ( m ) + zptr ( i ) - aa ( i ) * rst ( m ) end do zptr ( n - 1 ) = bb ( n ) * x ( m ) - aa ( n ) * rst ( m ) ! Omit z(n), which is always zero end do else ! FIR do m = 1 , nx rst ( m ) = bb ( 1 ) * x ( m ) + zptr ( 1 ) do i = 2 , n - 1 zptr ( i - 1 ) = bb ( i ) * x ( m ) + zptr ( i ) end do ! Omit z(n), which is always zero end do end if ! End return ! Memory Error Handling 10 continue allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) \"Memory allocation error flag \" , flag , \".\" call errmgr % report_error ( \"filter\" , trim ( errmsg ), & SPCTRM_MEMORY_ERROR ) return ! Filter Coefficient Array A Size Error Handler 20 continue allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) \"The filter coefficient array 'A' must have at \" // & \"least 1 element, but was found to have \" , na , \" elements.\" call errmgr % report_error ( \"filter\" , trim ( errmsg ), SPCTRM_ARRAY_SIZE_ERROR ) return ! Filter Coefficient Array Value Error Handler 30 continue call errmgr % report_error ( \"filter\" , & \"The 'A(1)' coefficient must be non-zero.\" , & SPCTRM_INVALID_INPUT_ERROR ) return ! Input delays array is not sized correctly 40 continue allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 101 ) \"The filter delay array was expected to be of size \" , & n - 1 , \"; however, was found to be of size \" , size ( delays ), \".\" call errmgr % report_error ( \"filter\" , trim ( errmsg ), SPCTRM_ARRAY_SIZE_ERROR ) return ! Formatting 100 format ( A , I0 , A ) 101 format ( A , I0 , A , I0 ) end function ! ------------------------------------------------------------------------------ function moving_average_filter ( navg , x , err ) result ( rst ) !! Applies a moving average filter to a signal. integer ( int32 ), intent ( in ) :: navg !! The size of the averaging window.  This parameter must be positive !! and non-zero. real ( real64 ), intent ( in ) :: x (:) !! An N-element array containing the signal to filter. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided can !! be used to retrieve information relating to any errors encountered !! during execution.  If not provided, a default implementation of the !! errors class is used internally to provide error handling.  Possible !! errors and warning messages that may be encountered are as follows. !! !!  - SPCTRM_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory !!      available. !! !!  - SPCTRM_INVALID_INPUT_ERROR: Occurs if navg is less than one. real ( real64 ), allocatable :: rst (:) !! An N-element array containing the filtered signal. ! Local Variables real ( real64 ) :: a ( 1 ), b ( navg ) class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( navg < 1 ) go to 10 ! Process a = 1.0d0 b = 1.0d0 / navg rst = filter ( b , a , x , err = errmgr ) ! End return ! NAVG invalid value (< 1) 10 continue call errmgr % report_error ( \"moving_average_filter\" , & \"The averaging window must have at least 1 element.\" , & SPCTRM_INVALID_INPUT_ERROR ) return end function ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\spectrum_filter.f90.html"},{"title":"spectrum_periodogram.f90 – SPECTRUM","text":"Contents Modules spectrum_periodogram Source Code spectrum_periodogram.f90 Source Code module spectrum_periodogram use iso_fortran_env use spectrum_windows use spectrum_routines use fftpack use ferror use spectrum_errors implicit none private public :: psd public :: csd public :: periodogram public :: cross_periodogram contains ! ------------------------------------------------------------------------------ function psd ( win , x , fs , nfft , err ) result ( rst ) !! Computes the power spectral density (PSD) of a signal via Welch's !! method. !! !! References !! !! - Welch, P.D. \"The Use of Fast Fourier Transform for the Estimation of !!  Power Spectra: A Method Based on Time Averaging Over Short, Modified !!  Periodograms.\" IEEE Transactions on Audio and Electroacoustics, !!  AU-15 (2): 70-73, 1967. !! !! - [Wikipedia - Welch's Method](https://en.wikipedia.org/wiki/Welch%27s_method) class ( window ), intent ( in ) :: win !! The window to apply.  The size of the window must be non-zero and !! positive-valued. real ( real64 ), intent ( in ) :: x (:) !! The signal to transform. real ( real64 ), intent ( in ), optional :: fs !! An optional input, that if supplied, allows for normalization of !! the computed spectrum by the frequency resolution. integer ( int32 ), intent ( in ), optional :: nfft !! An optional input that can be used to force the length of each !! individual DFT operation by padding any remaining space with zeros. !! If not supplied, the window size is used to determine the size of !! the DFT. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided can !! be used to retrieve information relating to any errors encountered !! during execution.  If not provided, a default implementation of the !! errors class is used internally to provide error handling.  Possible !! errors and warning messages that may be encountered are as follows. !! !!  - SPCTRM_MEMORY_ERROR: Occurs if a memory allocation error occurs. !! !!  - SPCTRM_INVALID_INPUT_ERROR: Occurs if win is not sized !!      appropriately. real ( real64 ), allocatable :: rst (:) !! An array containing the discrete PSD estimate.  The estimate is !! returned at discrete frequency intervals that can be determined by !! a call to frequency_bin_width. ! Local Variables logical :: init integer ( int32 ) :: i , nx , nxfrm , nw , nk , nf , lwork , flag real ( real64 ) :: fres , fac real ( real64 ), allocatable , dimension (:) :: work , xw , buffer complex ( real64 ), allocatable :: cwork (:) class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if nx = size ( x ) nw = win % size if ( present ( nfft )) then nf = nfft else nf = nw end if nxfrm = compute_transform_length ( nf ) nk = compute_overlap_segment_count ( nx , nw ) lwork = 3 * nf + 15 ! Input Checking if ( size ( x ) < 2 ) go to 20 ! Memory Allocation allocate ( rst ( nxfrm ), stat = flag , source = 0.0d0 ) if ( flag == 0 ) allocate ( work ( lwork ), stat = flag ) if ( flag == 0 ) allocate ( xw ( nw ), stat = flag ) if ( flag == 0 ) allocate ( buffer ( nxfrm ), stat = flag ) if ( flag == 0 ) allocate ( cwork ( nxfrm ), stat = flag ) if ( flag /= 0 ) go to 10 ! Cycle over each segment init = . true . do i = 1 , nk call overlap ( x , i , nw , xw ) call periodogram_driver ( win , xw , buffer , fs , nf , work , init , cwork , & errmgr ) if ( errmgr % has_error_occurred ()) return rst = rst + buffer init = . false . end do ! Average the result rst = rst / real ( nk , real64 ) ! End return ! Memory Error Handling 10 continue allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) \"Memory allocation error flag \" , flag , \".\" call errmgr % report_error ( \"psd_welch\" , trim ( errmsg ), SPCTRM_MEMORY_ERROR ) return ! Window Size Error 20 continue allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) & \"The window must have at least 2 points, but was found to have \" , & nx , \".\" call errmgr % report_error ( \"psd_welch\" , trim ( errmsg ), & SPCTRM_INVALID_INPUT_ERROR ) return ! Formatting 100 format ( A , I0 , A ) end function ! ------------------------------------------------------------------------------ function csd ( win , x , y , fs , nfft , err ) result ( rst ) !! Computes the cross spectral density (CSD) of a signal via Welch's !! method (sometimes referred to as cross power spectral density !! or CPSD). !! !! References !! !! - Welch, P.D. \"The Use of Fast Fourier Transform for the Estimation of !!  Power Spectra: A Method Based on Time Averaging Over Short, Modified !!  Periodograms.\" IEEE Transactions on Audio and Electroacoustics, !!  AU-15 (2): 70-73, 1967. !! !! - [Wikipedia - Welch's Method](https://en.wikipedia.org/wiki/Welch%27s_method) !! !! - [Wikipedia - Cross Power Spectral Density](https://en.wikipedia.org/wiki/Spectral_density#Cross-spectral_density) class ( window ), intent ( in ) :: win !! The window to apply.  The size of the window must be non-zero and !! positive-valued. real ( real64 ), intent ( in ) :: x (:) !! The first N-element signal to transform. real ( real64 ), intent ( in ) :: y (:) !! The second N-element signal to transform. real ( real64 ), intent ( in ), optional :: fs !! An optional input, that if supplied, allows for normalization of !! the computed spectrum by the frequency resolution. integer ( int32 ), intent ( in ), optional :: nfft !! An optional input that can be used to force the length of each !! individual DFT operation by padding any remaining space with zeros. !! If not supplied, the window size is used to determine the size of !! the DFT. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided can !! be used to retrieve information relating to any errors encountered !! during execution.  If not provided, a default implementation of the !! errors class is used internally to provide error handling.  Possible !! errors and warning messages that may be encountered are as follows. !! !!  - SPCTRM_MEMORY_ERROR: Occurs if a memory allocation error occurs. !! !!  - SPCTRM_INVALID_INPUT_ERROR: Occurs if win is not sized !!      appropriately. !! !! - SPCTRM_ARRAY_SIZE_MISMATCH_ERROR: Occurs if x and y are not the !!      same size. complex ( real64 ), allocatable :: rst (:) !! An array containing the discrete CSD estimate.  The estimate is !! returned at discrete frequency intervals that can be determined by !! a call to frequency_bin_width. ! Local Variables logical :: init integer ( int32 ) :: i , nx , ny , nw , nk , nf , lwork , flag , nxfrm real ( real64 ) :: fres , fac real ( real64 ), allocatable , dimension (:) :: work , xw , yw complex ( real64 ), allocatable , dimension (:) :: cwork , buffer class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if nx = size ( x ) ny = size ( y ) nw = win % size if ( present ( nfft )) then nf = nfft else nf = nw end if nxfrm = compute_transform_length ( nf ) nk = compute_overlap_segment_count ( nx , nw ) lwork = 4 * nf + 15 ! Input Checking if ( nx < 2 . or . ny < 2 ) go to 20 ! Memory Allocation allocate ( rst ( nxfrm ), stat = flag , source = ( 0.0d0 , 0.0d0 )) if ( flag == 0 ) allocate ( work ( lwork ), stat = flag ) if ( flag == 0 ) allocate ( xw ( nw ), stat = flag ) if ( flag == 0 ) allocate ( yw ( nw ), stat = flag ) if ( flag == 0 ) allocate ( buffer ( nxfrm ), stat = flag ) if ( flag == 0 ) allocate ( cwork ( 2 * nxfrm ), stat = flag ) if ( flag /= 0 ) go to 10 ! Cycle over each segment init = . true . do i = 1 , nk call overlap ( x , i , nw , xw ) call overlap ( y , i , nw , yw ) call cross_periodogram_driver ( win , xw , yw , buffer , fs , nf , work , & init , cwork , errmgr ) if ( errmgr % has_error_occurred ()) return rst = rst + buffer init = . false . end do ! Average the result rst = rst / real ( nk , real64 ) ! End return ! Memory Error Handling 10 continue allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) \"Memory allocation error flag \" , flag , \".\" call errmgr % report_error ( \"csd_welch\" , trim ( errmsg ), SPCTRM_MEMORY_ERROR ) return ! Window Size Error 20 continue allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) & \"The window must have at least 2 points, but was found to have \" , & nx , \".\" call errmgr % report_error ( \"csd_welch\" , trim ( errmsg ), & SPCTRM_INVALID_INPUT_ERROR ) return ! Array Size Mismatch Error 30 continue allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 101 ) \"The two arrays must be the same length.  \" // & \"Array X was found to be of length \" , nx , \", and array Y was \" // & \"found to be of length \" , ny , \".\" call errmgr % report_error ( \"csd_welch\" , trim ( errmsg ), & SPCTRM_ARRAY_SIZE_MISMATCH_ERROR ) return ! Formatting 100 format ( A , I0 , A ) 101 format ( A , I0 , A , I0 , A ) end function ! ------------------------------------------------------------------------------ module function periodogram ( win , x , fs , nfft , err ) result ( rst ) !! Computes the periodogram of a signal. class ( window ), intent ( in ) :: win !! The window to apply.  The size of the window must be non-zero and !! positive-valued. real ( real64 ), intent ( in ) :: x (:) !! The signal to transform. real ( real64 ), intent ( in ), optional :: fs !! An optional input, that if supplied, allows for normalization of !! the computed spectrum by the frequency resolution. integer ( int32 ), intent ( in ), optional :: nfft !! An optional input that can be used to force the length of each !! individual DFT operation by padding any remaining space with zeros. !! If not supplied, the window size is used to determine the size of !! the DFT. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided can !! be used to retrieve information relating to any errors encountered !! during execution.  If not provided, a default implementation of the !! errors class is used internally to provide error handling.  Possible !! errors and warning messages that may be encountered are as follows. !! !!  - SPCTRM_MEMORY_ERROR: Occurs if a memory allocation error occurs. !! !!  - SPCTRM_INVALID_INPUT_ERROR: Occurs if win is not sized !!      appropriately. real ( real64 ), allocatable :: rst (:) !! An array containing the discrete PSD estimate.  The estimate is !! returned at discrete frequency intervals that can be determined by !! a call to frequency_bin_width. ! Local Variables integer ( int32 ) :: n , nxfrm , nf , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if n = size ( x ) if ( present ( nfft )) then nf = nfft else nf = n end if nxfrm = compute_transform_length ( nf ) ! Memory Allocation allocate ( rst ( nxfrm ), stat = flag ) if ( flag /= 0 ) go to 10 ! Process call periodogram_driver ( win , x , rst , fs = fs , nfft = nfft , err = errmgr ) ! End return ! Memory Error Handling 10 continue allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) \"Memory allocation error flag \" , flag , \".\" call errmgr % report_error ( \"periodogram\" , trim ( errmsg ), & SPCTRM_MEMORY_ERROR ) return ! Formatting 100 format ( A , I0 , A ) end function ! ------------------------------------------------------------------------------ module function cross_periodogram ( win , x , y , fs , nfft , err ) result ( rst ) !! Computes the cross-spectral periodogram of two signals. class ( window ), intent ( in ) :: win !! The window to apply.  The size of the window must be non-zero and !! positive-valued. real ( real64 ), intent ( in ) :: x (:) !! The first N-element signal to transform. real ( real64 ), intent ( in ) :: y (:) !! The second N-element signal to transform. real ( real64 ), intent ( in ), optional :: fs !! An optional input, that if supplied, allows for normalization of !! the computed spectrum by the frequency resolution. integer ( int32 ), intent ( in ), optional :: nfft !! An optional input that can be used to force the length of each !! individual DFT operation by padding any remaining space with zeros. !! If not supplied, the window size is used to determine the size of !! the DFT. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided can !! be used to retrieve information relating to any errors encountered !! during execution.  If not provided, a default implementation of the !! errors class is used internally to provide error handling.  Possible !! errors and warning messages that may be encountered are as follows. !! !!  - SPCTRM_MEMORY_ERROR: Occurs if a memory allocation error occurs. !! !!  - SPCTRM_INVALID_INPUT_ERROR: Occurs if win is not sized !!      appropriately. !! !!  - SPCTRM_ARRAY_SIZE_MISMATCH_ERROR: Occurs if x and y are not the !!      same size, or if x and y are not the same size as the window !!      win. complex ( real64 ), allocatable :: rst (:) !! An array containing the discrete cross periodogram estimate.  The !! estimate is returned at discrete frequency intervals that can be !! determined by a call to frequency_bin_width. ! Local Variables integer ( int32 ) :: nx , nxfrm , nf , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if nx = size ( x ) if ( present ( nfft )) then nf = nfft else nf = nx end if nxfrm = compute_transform_length ( nf ) ! Memory Allocation allocate ( rst ( nxfrm ), stat = flag ) if ( flag /= 0 ) go to 10 ! Process call cross_periodogram_driver ( win , x , y , rst , fs = fs , nfft = nfft , & err = errmgr ) ! End return ! Memory Error Handling 10 continue allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) \"Memory allocation error flag \" , flag , \".\" call errmgr % report_error ( \"cross_periodogram\" , trim ( errmsg ), & SPCTRM_MEMORY_ERROR ) return ! Formatting 100 format ( A , I0 , A ) end function ! ------------------------------------------------------------------------------ subroutine periodogram_driver ( win , x , xfrm , fs , nfft , work , initxfrm , & cwork , err ) ! Arguments class ( window ), intent ( in ) :: win ! size = n real ( real64 ), intent ( in ) :: x (:) ! size = n real ( real64 ), intent ( out ) :: xfrm (:) ! size = m = (nfft + 1) / 2 or nfft / 2 + 1 real ( real64 ), intent ( in ), optional :: fs integer ( int32 ), intent ( in ), optional :: nfft ! defaults to n, must be at least n real ( real64 ), intent ( out ), optional , target :: work (:) ! size = 3 * nfft + 15 logical , intent ( in ), optional :: initxfrm complex ( real64 ), intent ( out ), optional , target :: cwork (:) ! size = m class ( errors ), intent ( inout ), optional , target :: err ! Local Variables logical :: init integer ( int32 ) :: i , j , nx , nxfrm , nf , lw , lwork , flag real ( real64 ) :: wval , wsum , scale , fac , df real ( real64 ), allocatable , target , dimension (:) :: wdef real ( real64 ), pointer , dimension (:) :: w , xw complex ( real64 ), allocatable , target , dimension (:) :: cwdef complex ( real64 ), pointer , dimension (:) :: cw class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if nx = size ( x ) if ( present ( nfft )) then nf = nfft else nf = nx end if nxfrm = compute_transform_length ( nf ) lw = 2 * nf + 15 lwork = lw + nf if ( present ( work ) . and . present ( initxfrm )) then init = initxfrm else init = . true . end if if ( mod ( nx , 2 ) == 0 ) then scale = 2.0d0 / nx else scale = 2.0d0 / ( nx - 1.0d0 ) end if ! Input Checking if ( win % size /= nx ) go to 20 if ( size ( xfrm ) /= nxfrm ) go to 50 if ( nf < nx ) go to 60 ! Workspace if ( present ( work )) then if ( size ( work ) < lwork ) go to 30 w ( 1 : lw ) => work ( 1 : lw ) xw ( 1 : nf ) => work ( lw + 1 : lwork ) else allocate ( wdef ( lwork ), stat = flag ) if ( flag /= 0 ) go to 10 w ( 1 : lw ) => wdef ( 1 : lw ) xw ( 1 : nf ) => wdef ( lw + 1 : lwork ) end if if ( init ) call dffti ( nf , w ) if ( present ( cwork )) then if ( size ( cwork ) < nxfrm ) go to 40 cw ( 1 : nxfrm ) => cwork ( 1 : nxfrm ) else allocate ( cwdef ( nxfrm ), stat = flag ) if ( flag /= 0 ) go to 10 cw ( 1 : nxfrm ) => cwdef ( 1 : nxfrm ) end if ! Apply the window wsum = 0.0d0 do i = 1 , nx j = i - 1 wval = win % evaluate ( j ) wsum = wsum + wval xw ( i ) = wval * x ( i ) end do fac = nx / wsum ! Pad with zeros if ( nf > nx ) xw ( nx + 1 : nf ) = 0.0d0 ! Compute the transform call dfftf ( nf , xw , w ) call unpack_real_transform ( xw , cw , fac * scale ) ! Compute the power from the windowed transform xfrm = real ( cw * conjg ( cw )) ! Normalize by frequency if ( present ( fs )) then df = frequency_bin_width ( fs , nf ) xfrm = xfrm / df end if ! End return ! Memory Error Handling 10 continue allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) \"Memory allocation error flag \" , flag , \".\" call errmgr % report_error ( \"periodogram_driver\" , trim ( errmsg ), & SPCTRM_MEMORY_ERROR ) return ! Window Size Error 20 continue allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 101 ) \"The window size (\" , win % size , & \") must be the same size as the signal array (\" , nx , \").\" call errmgr % report_error ( \"periodogram_driver\" , trim ( errmsg ), & SPCTRM_ARRAY_SIZE_MISMATCH_ERROR ) return ! Workspace Too Small Error 30 continue allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 101 ) \"The workspace array was expected to have \" // & \"a length of \" , lwork , \" elements, but was found to have \" , & size ( work ), \" elements.\" call errmgr % report_error ( \"periodogram_driver\" , trim ( errmsg ), & SPCTRM_ARRAY_SIZE_ERROR ) return ! Complex-Valued Workspace Too Small Error 40 continue allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 101 ) \"The complex-valued workspace array was expected \" // & \"to have a length of \" , nxfrm , \" elements, but was found to have \" , & size ( cwork ), \" elements.\" call errmgr % report_error ( \"periodogram_driver\" , trim ( errmsg ), & SPCTRM_ARRAY_SIZE_ERROR ) return ! Output Array Size Error 50 continue allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 101 ) \"The output array was expected to have a length of \" , & nxfrm , \" elements, but was found to have \" , size ( xfrm ), \" elements.\" call errmgr % report_error ( \"periodogram_driver\" , trim ( errmsg ), & SPCTRM_ARRAY_SIZE_ERROR ) return ! Too small of NFFT 60 continue allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 101 ) \"The length of the FFT (\" , nf , & \") must be at least the size of the window (\" , nx , \").\" call errmgr % report_error ( \"periodogram_driver\" , trim ( errmsg ), & SPCTRM_INVALID_INPUT_ERROR ) return ! Formatting 100 format ( A , I0 , A ) 101 format ( A , I0 , A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine cross_periodogram_driver ( win , x , y , xfrm , fs , nfft , work , & initxfrm , cwork , err ) ! Arguments class ( window ), intent ( in ) :: win ! size = n real ( real64 ), intent ( in ) :: x (:), y (:) ! size = n complex ( real64 ), intent ( out ) :: xfrm (:) ! size = m = (nfft + 1) / 2 or nfft / 2 + 1 real ( real64 ), intent ( in ), optional :: fs integer ( int32 ), intent ( in ), optional :: nfft ! defaults to n, must be at least n real ( real64 ), intent ( out ), optional , target :: work (:) ! size = 4 * nfft + 15 logical , intent ( in ), optional :: initxfrm complex ( real64 ), intent ( out ), optional , target :: cwork (:) ! size = 2 * m class ( errors ), intent ( inout ), optional , target :: err ! Local Variables logical :: init integer ( int32 ) :: i , j , nx , ny , nxfrm , nf , lw , lwork , flag real ( real64 ) :: wval , wsum , scale , fac , df real ( real64 ), allocatable , target , dimension (:) :: wdef real ( real64 ), pointer , dimension (:) :: w , xw , yw complex ( real64 ), allocatable , target , dimension (:) :: cwdef complex ( real64 ), pointer , dimension (:) :: cx , cy class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if nx = size ( x ) ny = size ( y ) if ( present ( nfft )) then nf = nfft else nf = nx end if nxfrm = compute_transform_length ( nf ) lw = 2 * nf + 15 lwork = lw + 2 * nf if ( present ( work ) . and . present ( initxfrm )) then init = initxfrm else init = . true . end if if ( mod ( nx , 2 ) == 0 ) then scale = 2.0d0 / nx else scale = 2.0d0 / ( nx - 1.0d0 ) end if ! Input Checking if ( nx /= ny ) go to 60 if ( win % size /= nx ) go to 20 if ( size ( xfrm ) /= nxfrm ) go to 50 if ( nf < nx ) go to 70 ! Workspace if ( present ( work )) then if ( size ( work ) < lwork ) go to 30 w ( 1 : lw ) => work ( 1 : lw ) xw ( 1 : nf ) => work ( lw + 1 : lw + nf ) yw ( 1 : nf ) => work ( lw + nf + 1 : lwork ) else allocate ( wdef ( lwork ), stat = flag ) if ( flag /= 0 ) go to 10 w ( 1 : lw ) => wdef ( 1 : lw ) xw ( 1 : nf ) => wdef ( lw + 1 : lw + nf ) yw ( 1 : nf ) => wdef ( lw + nf + 1 : lwork ) end if if ( init ) call dffti ( nf , w ) if ( present ( cwork )) then if ( size ( cwork ) /= 2 * nxfrm ) go to 40 cx ( 1 : nxfrm ) => cwork ( 1 : nxfrm ) cy ( 1 : nxfrm ) => cwork ( nxfrm + 1 : 2 * nxfrm ) else allocate ( cwdef ( 2 * nxfrm ), stat = flag ) if ( flag /= 0 ) go to 10 cx ( 1 : nxfrm ) => cwdef ( 1 : nxfrm ) cy ( 1 : nxfrm ) => cwdef ( nxfrm + 1 : 2 * nxfrm ) end if ! Apply the window wsum = 0.0d0 do i = 1 , nx j = i - 1 wval = win % evaluate ( j ) wsum = wsum + wval xw ( i ) = wval * x ( i ) yw ( i ) = wval * y ( i ) end do fac = nx / wsum ! Pad with zeros if ( nf > nx ) then xw ( nx + 1 : nf ) = 0.0d0 yw ( ny + 1 : nf ) = 0.0d0 end if ! Compute the transforms call dfftf ( nf , xw , w ) call dfftf ( nf , yw , w ) call unpack_real_transform ( xw , cx , fac * scale ) call unpack_real_transform ( yw , cy , fac * scale ) ! Compute the cross spectrum xfrm = cx * conjg ( cy ) ! Normalize by frequency if ( present ( fs )) then df = frequency_bin_width ( fs , nf ) xfrm = xfrm / df end if ! End return ! Memory Error Handling 10 continue allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) \"Memory allocation error flag \" , flag , \".\" call errmgr % report_error ( \"cross_periodogram_driver\" , trim ( errmsg ), & SPCTRM_MEMORY_ERROR ) return ! Window Size Error 20 continue allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 101 ) \"The window size (\" , win % size , & \") must be the same size as the signal array (\" , nx , \").\" call errmgr % report_error ( \"cross_periodogram_driver\" , trim ( errmsg ), & SPCTRM_ARRAY_SIZE_MISMATCH_ERROR ) return ! Workspace Too Small Error 30 continue allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 101 ) \"The workspace array was expected to have \" // & \"a length of \" , lwork , \" elements, but was found to have \" , & size ( work ), \" elements.\" call errmgr % report_error ( \"cross_periodogram_driver\" , trim ( errmsg ), & SPCTRM_ARRAY_SIZE_ERROR ) return ! Complex-Valued Workspace Too Small Error 40 continue allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 101 ) \"The complex-valued workspace array was expected \" // & \"to have a length of \" , 2 * nxfrm , & \" elements, but was found to have \" , size ( cwork ), \" elements.\" call errmgr % report_error ( \"cross_periodogram_driver\" , trim ( errmsg ), & SPCTRM_ARRAY_SIZE_ERROR ) return ! Output Array Size Error 50 continue allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 101 ) \"The output array was expected to have a length of \" , & nxfrm , \" elements, but was found to have \" , size ( xfrm ), \" elements.\" call errmgr % report_error ( \"cross_periodogram_driver\" , trim ( errmsg ), & SPCTRM_ARRAY_SIZE_ERROR ) return ! X & Y are not the same size 60 continue allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 101 ) \"The first input array (size = \" , nx , & \"), and the second input array (size = \" , ny , & \") must be the same size.\" call errmgr % report_error ( \"cross_periodogram_driver\" , trim ( errmsg ), & SPCTRM_ARRAY_SIZE_MISMATCH_ERROR ) ! Too small of NFFT 70 continue allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 101 ) \"The length of the FFT (\" , nf , & \") must be at least the size of the window (\" , nx , \").\" call errmgr % report_error ( \"cross_periodogram_driver\" , trim ( errmsg ), & SPCTRM_INVALID_INPUT_ERROR ) return ! Formatting 100 format ( A , I0 , A ) 101 format ( A , I0 , A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\spectrum_periodogram.f90.html"},{"title":"spectrum_routines.f90 – SPECTRUM","text":"Contents Modules spectrum_routines Source Code spectrum_routines.f90 Source Code module spectrum_routines use iso_fortran_env implicit none private public :: compute_transform_length public :: frequency_bin_width public :: is_power_of_two public :: next_power_of_two public :: unpack_real_transform public :: cumulative_sum public :: unwrap public :: difference public :: compute_overlap_segment_count public :: overlap contains ! ------------------------------------------------------------------------------ pure function compute_transform_length ( n ) result ( rst ) !! Computes the length of the positive half of a discrete Fourier !! transform for a specific signal length. !! !! The length of the discrete Fourier transform is determined as follows. !! !! If n is even, !!  m = \\frac{n}{2} + 1  !! !! else; !!  m = \\frac{n + 1}{2} . integer ( int32 ), intent ( in ) :: n !! The signal length (length of the signal put forth to the Fourier !! transform). integer ( int32 ) :: rst !! The length of the positive half of the discrete Fourier transform. if ( mod ( n , 2 ) == 0 ) then rst = n / 2 + 1 else rst = ( n + 1 ) / 2 end if end function ! ------------------------------------------------------------------------------ pure elemental function frequency_bin_width ( fs , n ) result ( rst ) !! Computes the bin width for a discrete frequency spectrum based !! upon the data sample rate. !! !! The frequency bin width is computed as follows. !! !!  \\Delta f = \\frac{f_{s}}{2 \\left(m - 1 \\right)}  !! !! where m is computed via compute_transform_length. real ( real64 ), intent ( in ) :: fs !! The rate at which the signal was sampled.  The units of this value !! will be the units of the output. integer ( int32 ), intent ( in ) :: n !! The signal length (length of the signal put forth to the !! Fourier transform). real ( real64 ) :: rst !! The frequency bin width. ! Local Variables integer ( int32 ) :: m ! Process m = compute_transform_length ( n ) rst = 0.5d0 * fs / ( m - 1.0d0 ) end function ! ------------------------------------------------------------------------------ pure elemental function is_power_of_two ( n ) result ( rst ) !! Tests to see if a value is an integer power of two. integer ( int32 ), intent ( in ) :: n !! The value to test. logical :: rst !! Returns true if n is a power of two; else, false. ! Process rst = ( n /= 0 ) . and . ( iand ( n , n - 1 ) == 0 ) ! This is equivalent to the C form : n != 0 && ((n & (n - 1)) == 0) end function ! ------------------------------------------------------------------------------ pure elemental function next_power_of_two ( n ) result ( rst ) !! Provides the next higher integer power of two. integer ( int32 ), intent ( in ) :: n !! The value to test. integer ( int32 ) :: rst !! The next power of two higher than n.  If n is already a power of two, !! its value is simply returned.  For instance, if n is set to 128, !! then a value of 7 is returned ( 2&#94;7 = 128  ). ! Process rst = ceiling ( log ( real ( n )) / log ( 2.0 ), int32 ) end function ! ------------------------------------------------------------------------------ pure subroutine unpack_real_transform ( x , cx , fac ) !! Unpacks a real-valued transform into its complex-valued format. real ( real64 ), intent ( in ) :: x (:) !! The complex-valued signal stored in a real-valued array.  This array !! is assumed to be of length N. complex ( real64 ), intent ( out ) :: cx (:) !! The M-element array where the complex form of x is written.  M is !! determined by calling compute_transform_length(N). real ( real64 ), intent ( in ), optional :: fac !! An optional scaling input.  The default is 1 such that no scaling !! is performed. ! Local Variables integer ( int32 ) :: i , nx , nxfrm real ( real64 ) :: f logical :: is_even ! Initialization nx = size ( x ) is_even = mod ( nx , 2 ) == 0 nxfrm = compute_transform_length ( nx ) if ( present ( fac )) then f = fac else f = 1.0d0 end if ! Quick Return if ( f == 0.0d0 ) then cx = ( 0.0d0 , 0.0d0 ) return end if ! Process if ( f == 1.0d0 ) then cx ( 1 ) = cmplx ( x ( 1 ), 0.0d0 , real64 ) ! the DC term is always real if ( is_even ) then do i = 2 , nxfrm - 1 cx ( i ) = cmplx ( x ( 2 * i - 2 ), x ( 2 * i - 1 ), real64 ) end do cx ( nxfrm ) = cmplx ( x ( nx ), 0.0d0 , real64 ) ! always real for even-lengths else do i = 2 , nxfrm cx ( i ) = cmplx ( x ( 2 * i - 2 ), x ( 2 * i - 1 ), real64 ) end do end if else cx ( 1 ) = f * cmplx ( x ( 1 ), 0.0d0 , real64 ) ! the DC term is always real if ( is_even ) then do i = 2 , nxfrm - 1 cx ( i ) = f * cmplx ( x ( 2 * i - 2 ), x ( 2 * i - 1 ), real64 ) end do cx ( nxfrm ) = f * cmplx ( x ( nx ), 0.0d0 , real64 ) ! always real for even-lengths else do i = 2 , nxfrm cx ( i ) = f * cmplx ( x ( 2 * i - 2 ), x ( 2 * i - 1 ), real64 ) end do end if end if end subroutine ! ------------------------------------------------------------------------------ ! Rounds a number to the required precision (p), but rounds 0.5 down to the ! next lowest integer. pure elemental function round ( x , p ) result ( rst ) ! Arguments real ( real64 ), intent ( in ) :: x integer ( int32 ), intent ( in ) :: p real ( real64 ) :: rst ! Local Variables real ( real64 ) :: scale , val ! Process scale = 1 0.0d0 ** ( - p ) val = x * scale + 0.49d0 rst = floor ( val ) / scale end function ! ------------------------------------------------------------------------------ pure function difference ( x ) result ( rst ) !! Computes the difference between each element in an array. real ( real64 ), intent ( in ) :: x (:) !! The N-element array on which to operate. real ( real64 ), allocatable :: rst (:) !! The N-1 element array containing the difference between each element !! in x. ! Local Variables integer ( int32 ) :: i , n ! Initialization n = size ( x ) if ( n == 0 ) return ! Process if ( n == 1 ) then allocate ( rst ( 1 ), source = 0.0d0 ) return end if allocate ( rst ( n - 1 )) do i = 1 , n - 1 rst ( i ) = x ( i + 1 ) - x ( i ) end do end function ! ------------------------------------------------------------------------------ pure function cumulative_sum ( x ) result ( rst ) !! Computes the cumulative sum of an array. real ( real64 ), intent ( in ) :: x (:) !! The N-element array on which to operate. real ( real64 ), allocatable :: rst (:) !! An N-element array containing the cumulative sum of each element !! in x (e.g. cumulative_sum(x) = [x(1), x(1) + x(2), ...]). ! Local Variables integer ( int32 ) :: i , n ! Initialization n = size ( x ) allocate ( rst ( n )) ! Process rst ( 1 ) = x ( 1 ) do i = 2 , n rst ( i ) = rst ( i - 1 ) + x ( i ) end do end function ! ------------------------------------------------------------------------------ subroutine unwrap ( x , tol ) !! Shifts phase angle arrays to deal with jumps greater than or equal !! to tol by adding multiples of   \\pm 2 \\pi  until !! the jump is less than tol. real ( real64 ), intent ( inout ) :: x (:) !! On input, the phase array.  On output, the unwrapped phase array. real ( real64 ), intent ( in ), optional :: tol !! The tolerance value. ! Parameters real ( real64 ), parameter :: pi = 2.0d0 * acos ( 0.0d0 ) ! Local Variables integer ( int32 ) :: i , n real ( real64 ), allocatable , dimension (:) :: dp , dpcorr real ( real64 ) :: cutoff ! Initialization n = size ( x ) if ( present ( tol )) then cutoff = tol else cutoff = pi end if ! Compute the incremental variations dp = difference ( x ) ! Compute how many time 2*pi we're off, and round to the nearest integer ! with the tie-breaker rounding n+0.5 down to n. dpcorr = round ( dp / ( 2.0d0 * pi ), - 1 ) ! Stop the jump from happening if dp < cutoff do i = 1 , n - 1 if ( abs ( dp ( i )) < cutoff ) dpcorr ( i ) = 0.0d0 end do ! Apply the corrections x ( 2 : n ) = x ( 2 : n ) - ( 2.0d0 * pi ) * cumulative_sum ( dpcorr ) end subroutine ! ------------------------------------------------------------------------------ pure function compute_overlap_segment_count ( n , winsize ) result ( rst ) !! Computes the number of overlapped signals using a nominal 50% overlap. integer ( int32 ), intent ( in ) :: n !! The total length of the signal being overlapped. integer ( int32 ), intent ( in ) :: winsize !! The window size. integer ( int32 ) :: rst !! The number of segments. ! Local Variables integer ( int32 ) :: nxfrm ! Process nxfrm = compute_transform_length ( winsize ) rst = max (( n - 1 ) / nxfrm , 1 ) end function ! ------------------------------------------------------------------------------ pure subroutine overlap ( x , seg , winsize , buffer ) !! Extracts a segment from a signal allowing for a nominally 50% overlap. real ( real64 ), intent ( in ) :: x (:) !! An N-element array containing the entire signal. integer ( int32 ), intent ( in ) :: seg !! The one-based index of the segment to extract. integer ( int32 ), intent ( in ) :: winsize !! The size of the window (segment).  If this value is less than N, the !! end of the segment will be padded with zeros. real ( real64 ), intent ( out ) :: buffer (:) !! A winsize array where the segment will be written. ! Local Variables integer ( int32 ) :: k , nx , nxfrm , nk , noff , i1 , i2 real ( real64 ) :: del ! Initialization nx = size ( x ) nxfrm = compute_transform_length ( winsize ) nk = ( nx - 1 ) / nxfrm if ( nk > 1 ) then del = ( nx - winsize ) / ( nk - 1.0d0 ) else del = 0.0d0 end if ! Slice up the array if ( winsize > nx ) then buffer ( 1 : nx ) = x buffer ( nx + 1 : winsize ) = 0.0d0 else k = seg - 1 noff = int ( k * del + 0.5d0 , int32 ) i1 = noff + 1 i2 = i1 + winsize - 1 buffer = x ( i1 : i2 ) end if ! End return end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\spectrum_routines.f90.html"},{"title":"spectrum_tf.f90 – SPECTRUM","text":"Contents Modules spectrum_tf Source Code spectrum_tf.f90 Source Code module spectrum_tf use iso_fortran_env use spectrum_periodogram use spectrum_windows use spectrum_errors use ferror implicit none private public :: siso_transfer_function public :: SPCTRM_H1_ESTIMATOR public :: SPCTRM_H2_ESTIMATOR integer ( int32 ), parameter :: SPCTRM_H1_ESTIMATOR = 50002 !! A flag for requesting an H1 transfer function estimator.  An H1 !! estimator is best used when noise is uncorrelated with the input, !! and results in a transfer function estimate of the form !! !!  H_{1} = \\frac{P_{yx}}{P_{xx}} . integer ( int32 ), parameter :: SPCTRM_H2_ESTIMATOR = 50003 !! A flag for requesting an H2 transfer function estimator.  An H2 !! estimator is best used when noise is uncorrelated with the output, !! and results in a transfer function estimate of the form !! !!  H_{2} = \\frac{P_{yy}}{P_{xy}} . contains ! ------------------------------------------------------------------------------ ! REF: ! - https://github.com/giuliovv/tfest/blob/main/tfest/tfest.py ! - https://dsp.stackexchange.com/questions/71811/understanding-the-h1-and-h2-estimators ! - https://github.com/epezent/etfe/blob/main/include/ETFE.hpp function siso_transfer_function ( win , x , y , etype , nfft , err ) result ( rst ) !! Estimates the transfer function for a single-input/single-output !! (SISO) system. class ( window ), intent ( in ) :: win !! The window object. real ( real64 ), intent ( in ) :: x (:) !! An N-element array containing the input signal. real ( real64 ), intent ( in ) :: y (:) !! An N-element array containing the output signal. integer ( int32 ), intent ( in ), optional :: etype !! An optional input that, if supplied, denotes the !! estimator to use.  If no value is specified, an H1 estimator is used. !! The following options are supported. !! !!  - SPCTRM_H1_ESTIMATOR: Uses an H1 estimate. !! !!  - SPCTRM_H2_ESTIMATOR: Uses an H2 estimate. !! !! If an unrecognized value is provided, the routine defaults to an !! H1 estimator. integer ( int32 ), intent ( in ), optional :: nfft !! An optional input that can be used to force the length of each !! individual DFT operation by padding any remaining space with zeros. !! If not supplied, the window size is used to determine the size of !! the DFT. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided can !! be used to retrieve information relating to any errors encountered !! during execution.  If not provided, a default implementation of the !! errors class is used internally to provide error handling.  Possible !! errors and warning messages that may be encountered are as follows. !! !!  - SPCTRM_MEMORY_ERROR: Occurs if a memory allocation error occurs. !! !!  - SPCTRM_INVALID_INPUT_ERROR: Occurs if win is not sized !!      appropriately. complex ( real64 ), allocatable :: rst (:) !! Returns the complex-valued transfer function estimate. ! Local Variables integer ( int32 ) :: est complex ( real64 ), allocatable , dimension (:) :: pcross real ( real64 ), allocatable , dimension (:) :: pwr class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( present ( etype )) then est = etype else est = SPCTRM_H1_ESTIMATOR end if if ( est /= SPCTRM_H1_ESTIMATOR . and . est /= SPCTRM_H2_ESTIMATOR ) then est = SPCTRM_H1_ESTIMATOR end if ! Process select case ( est ) case ( SPCTRM_H1_ESTIMATOR ) pcross = csd ( win , y , x , nfft = nfft , err = errmgr ) if ( errmgr % has_error_occurred ()) return pwr = psd ( win , x , nfft = nfft , err = errmgr ) if ( errmgr % has_error_occurred ()) return rst = pcross / pwr case ( SPCTRM_H2_ESTIMATOR ) pcross = csd ( win , x , y , nfft = nfft , err = errmgr ) if ( errmgr % has_error_occurred ()) return pwr = psd ( win , y , err = errmgr ) if ( errmgr % has_error_occurred ()) return rst = pwr / pcross end select end function ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\spectrum_tf.f90.html"},{"title":"spectrum_windows.f90 – SPECTRUM","text":"Contents Modules spectrum_windows Source Code spectrum_windows.f90 Source Code module spectrum_windows use iso_fortran_env implicit none private public :: window public :: window_function public :: rectangular_window public :: hann_window public :: hamming_window public :: welch_window public :: blackman_harris_window public :: flat_top_window real ( real64 ), parameter :: pi = 2.0d0 * acos ( 0.0d0 ) type , abstract :: window !! Defines the structure of a window. integer ( int32 ), public :: size = 0 !! The window size. contains procedure ( window_function ), public , deferred , pass :: evaluate end type interface pure function window_function ( this , bin ) result ( rst ) !! Evaluates the window function. use iso_fortran_env , only : real64 , int32 import window class ( window ), intent ( in ) :: this !! The window object. integer ( int32 ), intent ( in ) :: bin !! The index or bin number [0, n], where n is the window size. real ( real64 ) :: rst !! The function value. end function end interface !> @brief Defines a rectangular window. type , extends ( window ) :: rectangular_window !! Defines a rectangular window. contains procedure , public :: evaluate => rw_eval end type type , extends ( window ) :: hann_window !! Defines a Hann window. !! !!  w(j) = \\frac{1}{2} \\left( 1 - \\cos \\left( \\frac{2 \\pi j}{n} \\right) \\right) . !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Window_function) contains procedure , public :: evaluate => hann_eval end type type , extends ( window ) :: hamming_window !! Defines a Hamming window. !! !!  w(j) = 0.54 - 0.46 \\cos \\left( \\frac{2 \\pi j}{n} \\right)  !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Window_function) contains procedure , public :: evaluate => hamming_eval end type type , extends ( window ) :: welch_window !! Defines a Welch window. !! !!  w(j) = 1 - \\left( \\frac{j - \\frac{n}{2} }{ \\frac{n}{2} } \\right)&#94;2  !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Window_function) contains procedure , public :: evaluate => welch_eval end type type , extends ( window ) :: blackman_harris_window !! Defines a Blackman-Harris window. !! !!  w(j) = 0.3635819 - 0.4891775 \\cos \\left( \\frac{2 \\pi j}{n} \\right) !! + 0.1365995 \\cos \\left( \\frac{4 \\pi j}{n} \\right) - 0.0106411 !! \\cos \\left( \\frac{6 \\pi j}{n} \\right)  !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Window_function) contains procedure , public :: evaluate => bhw_eval end type type , extends ( window ) :: flat_top_window !! Defines a flat-top window. !! !!  w(j) = 0.21557895 - !! 0.41663158 \\cos \\left( \\frac{2 \\pi j}{N} \\right) + !! 0.277263158 \\cos \\left( \\frac{4 \\pi j}{N} \\right) - !! 0.083578947 \\cos \\left( \\frac{6 \\pi j}{N} \\right)  + !! 0.006947368 \\cos \\left( \\frac{8 \\pi j}{N} \\right)  !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Window_function) contains procedure , public :: evaluate => ftw_eval end type contains ! ------------------------------------------------------------------------------ pure function rw_eval ( this , bin ) result ( rst ) !! Evaluates the window function. class ( rectangular_window ), intent ( in ) :: this !! The rectangular_window object. integer ( int32 ), intent ( in ) :: bin !! The index or bin number [0, n], where n is the window size. real ( real64 ) :: rst !! The function value. rst = 1.0d0 end function ! ------------------------------------------------------------------------------ pure function hann_eval ( this , bin ) result ( rst ) !! Evaluates the window function. class ( hann_window ), intent ( in ) :: this !! The hann_window object. integer ( int32 ), intent ( in ) :: bin !! The index or bin number [0, n], where n is the window size. real ( real64 ) :: rst !! The function value. rst = 0.5d0 * ( 1.0d0 - cos ( 2.0d0 * pi * bin / this % size )) end function ! ------------------------------------------------------------------------------ pure function hamming_eval ( this , bin ) result ( rst ) !! Evaluates the window function. class ( hamming_window ), intent ( in ) :: this !! The hamming_window object. integer ( int32 ), intent ( in ) :: bin !! The index or bin number [0, n], where n is the window size. real ( real64 ) :: rst !! The function value. rst = 0.54d0 - 0.46d0 * cos ( 2.0d0 * pi * bin / this % size ) end function ! ------------------------------------------------------------------------------ pure function welch_eval ( this , bin ) result ( rst ) !! Evaluates the window function. class ( welch_window ), intent ( in ) :: this !! The welch_window object. integer ( int32 ), intent ( in ) :: bin !! The index or bin number [0, n], where n is the window size. real ( real64 ) :: rst !! The function value. real ( real64 ) :: halfsize halfsize = 0.5d0 * this % size rst = 1.0d0 - (( bin - halfsize ) / halfsize ) ** 2 end function ! ------------------------------------------------------------------------------ pure function bhw_eval ( this , bin ) result ( rst ) !! Evaluates the window function. class ( blackman_harris_window ), intent ( in ) :: this !! The blackman_harris_window object. integer ( int32 ), intent ( in ) :: bin !! The index or bin number [0, n], where n is the window size. real ( real64 ) :: rst !! The function value. rst = 0.35875d0 - & 0.48829d0 * cos ( 2.0d0 * pi * bin / this % size ) + & 0.14128d0 * cos ( 4.0d0 * pi * bin / this % size ) - & 0.01168d0 * cos ( 6.0d0 * pi * bin / this % size ) end function ! ------------------------------------------------------------------------------ pure function ftw_eval ( this , bin ) result ( rst ) !! Evaluates the window function. class ( flat_top_window ), intent ( in ) :: this !! The flat_top_window object. integer ( int32 ), intent ( in ) :: bin !! The index or bin number [0, n], where n is the window size. real ( real64 ) :: rst !! The function value. real ( real64 ), parameter :: a0 = 0.21557895d0 real ( real64 ), parameter :: a1 = 0.41663158d0 real ( real64 ), parameter :: a2 = 0.277263158d0 real ( real64 ), parameter :: a3 = 8.3578947d-2 real ( real64 ), parameter :: a4 = 6.947368d-3 real ( real64 ) :: arg arg = pi * bin / this % size rst = a0 - a1 * cos ( 2.0d0 * arg ) + a2 * cos ( 4.0d0 * arg ) - & a3 * cos ( 6.0d0 * arg ) + a4 * cos ( 8.0d0 * arg ) end function ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\spectrum_windows.f90.html"}]}